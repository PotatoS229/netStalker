И снова всем привет, это курс по SQL, он будит самыв вероятнее всего коротким и простиым для освоения, ну что же предлягаю переходить сразу к делу 

Начнем данный курс, с самого важного, что такое данные?
Данные - это блоки, из которых строится мир, данные по всюду, и зная sql, вы станите тем, кто способен правильно работать с ними

Хочу подметить, я не являюсь человеком специализирующемся на SQL или на анализе данных. По этому я хочу написать данную статья узконаправленно, для тех кто является Backend разработчиком, я обсужу и расскажу основые и самые главняе вещи которые вам нужно знать. 

# Справочник по SQL для Backend-разработчика

## 1. Основные концепции

### Реляционные базы данных
- **Таблицы (Tables)** - структуры для хранения данных в строках и столбцах
- **Строки (Rows/Records)** - отдельные записи в таблице
- **Столбцы (Columns/Fields)** - атрибуты данных
- **Первичный ключ (Primary Key)** - уникальный идентификатор строки
- **Внешний ключ (Foreign Key)** - ссылка на первичный ключ другой таблицы
- **Индексы (Indexes)** - структуры для ускорения поиска

### Типы данных
```sql
-- Числовые
INT, INTEGER        -- целые числа
BIGINT              -- большие целые
DECIMAL(p,s), NUMERIC -- точные числа
FLOAT, REAL, DOUBLE -- числа с плавающей точкой

-- Строковые
CHAR(n)             -- строка фиксированной длины
VARCHAR(n)          -- строка переменной длины (до n)
TEXT                -- большой текст

-- Дата и время
DATE                -- дата (YYYY-MM-DD)
TIME                -- время (HH:MM:SS)
DATETIME, TIMESTAMP -- дата и время
TIMESTAMP WITH TIME ZONE -- с часовым поясом

-- Логические
BOOLEAN, BOOL       -- true/false

-- Бинарные
BLOB                -- двоичные данные
BYTEA               -- бинарные данные (PostgreSQL)

-- JSON
JSON                -- JSON данные
JSONB               -- бинарный JSON (PostgreSQL)
```

## 2. Основные операции (CRUD)

### Создание (CREATE)
```sql
-- Создание базы данных
CREATE DATABASE mydb;

-- Создание таблицы
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE
);

-- Создание таблицы со связями
CREATE TABLE orders (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL,
    total DECIMAL(10, 2),
    status VARCHAR(20) DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

### Чтение (SELECT)
```sql
-- Базовый SELECT
SELECT * FROM users;

-- Выбор конкретных полей
SELECT id, username, email FROM users;

-- С условием WHERE
SELECT * FROM users WHERE is_active = TRUE;

-- Сортировка
SELECT * FROM users ORDER BY created_at DESC;

-- Лимит и оффсет
SELECT * FROM users LIMIT 10 OFFSET 20;
-- Или эквивалентно
SELECT * FROM users LIMIT 20, 10;

-- Агрегатные функции
SELECT 
    COUNT(*) as total_users,
    AVG(id) as avg_id,
    MIN(created_at) as first_user,
    MAX(created_at) as last_user
FROM users;

-- Группировка
SELECT 
    DATE(created_at) as reg_date,
    COUNT(*) as registrations
FROM users
GROUP BY DATE(created_at)
HAVING COUNT(*) > 5;
```

### Обновление (UPDATE)
```sql
-- Обновление одной записи
UPDATE users 
SET email = 'new@email.com', updated_at = NOW()
WHERE id = 1;

-- Обновление нескольких записей
UPDATE users 
SET is_active = FALSE 
WHERE created_at < '2023-01-01';

-- Обновление с JOIN
UPDATE orders o
JOIN users u ON o.user_id = u.id
SET o.status = 'cancelled'
WHERE u.email = 'user@example.com';
```

### Удаление (DELETE)
```sql
-- Удаление конкретной записи
DELETE FROM users WHERE id = 1;

-- Удаление с условием
DELETE FROM logs WHERE created_at < DATE_SUB(NOW(), INTERVAL 30 DAY);

-- Очистка таблицы (осторожно!)
TRUNCATE TABLE temp_data;
```

## 3. JOIN операции

### INNER JOIN
```sql
-- Только совпадающие записи
SELECT u.username, o.id, o.total
FROM users u
INNER JOIN orders o ON u.id = o.user_id;
```

### LEFT JOIN
```sql
-- Все записи из левой таблицы + совпадения из правой
SELECT u.username, o.id, o.total
FROM users u
LEFT JOIN orders o ON u.id = o.user_id;
-- Можно заменить NULL значения
SELECT 
    u.username, 
    COALESCE(COUNT(o.id), 0) as order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id;
```

### RIGHT JOIN
```sql
-- Все записи из правой таблицы + совпадения из левой
SELECT u.username, o.id, o.total
FROM users u
RIGHT JOIN orders o ON u.id = o.user_id;
```

### FULL OUTER JOIN
```sql
-- Все записи из обеих таблиц
SELECT u.username, o.id, o.total
FROM users u
FULL OUTER JOIN orders o ON u.id = o.user_id;
```

### CROSS JOIN
```sql
-- Декартово произведение
SELECT u.username, p.product_name
FROM users u
CROSS JOIN products p;
```

## 4. Подзапросы (Subqueries)

### В WHERE
```sql
SELECT * FROM users 
WHERE id IN (SELECT user_id FROM orders WHERE total > 1000);

SELECT * FROM products
WHERE price > (SELECT AVG(price) FROM products);
```

### В SELECT
```sql
SELECT 
    u.username,
    (SELECT COUNT(*) FROM orders o WHERE o.user_id = u.id) as order_count
FROM users u;
```

### В FROM
```sql
SELECT 
    user_id,
    AVG(order_count) as avg_orders
FROM (
    SELECT 
        user_id,
        DATE(created_at) as order_date,
        COUNT(*) as order_count
    FROM orders
    GROUP BY user_id, DATE(created_at)
) as daily_orders
GROUP BY user_id;
```

## 5. Транзакции

```sql
-- Начало транзакции
START TRANSACTION;
-- или
BEGIN;

-- Ваши операции
INSERT INTO orders (user_id, total) VALUES (1, 100.00);
UPDATE users SET last_order_at = NOW() WHERE id = 1;

-- Подтверждение
COMMIT;

-- Откат при ошибке
ROLLBACK;

-- Транзакция с обработкой ошибок (пример для разных СУБД)
-- PostgreSQL
BEGIN;
SAVEPOINT my_savepoint;
-- операции
ROLLBACK TO SAVEPOINT my_savepoint; -- частичный откат
COMMIT;

-- MySQL с обработкой ошибок
DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
    ROLLBACK;
    RESIGNAL;
END;

START TRANSACTION;
-- операции
COMMIT;
```

## 6. Индексы и оптимизация

```sql
-- Создание индекса
CREATE INDEX idx_users_email ON users(email);
CREATE UNIQUE INDEX idx_users_username ON users(username);

-- Составной индекс
CREATE INDEX idx_orders_user_status ON orders(user_id, status);

-- Частичный индекс (PostgreSQL)
CREATE INDEX idx_active_users ON users(id) WHERE is_active = TRUE;

-- Удаление индекса
DROP INDEX idx_users_email;

-- EXPLAIN для анализа запросов
EXPLAIN SELECT * FROM users WHERE email = 'test@example.com';
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'test@example.com';
```

## 7. Оконные функции (Window Functions)

```sql
-- Нумерация строк
SELECT 
    id,
    username,
    ROW_NUMBER() OVER (ORDER BY created_at) as row_num,
    RANK() OVER (ORDER BY created_at) as rank_num,
    DENSE_RANK() OVER (ORDER BY created_at) as dense_rank_num
FROM users;

-- Агрегаты с окнами
SELECT 
    user_id,
    order_date,
    total,
    SUM(total) OVER (PARTITION BY user_id) as user_total,
    AVG(total) OVER (PARTITION BY user_id) as user_avg,
    LAG(total) OVER (PARTITION BY user_id ORDER BY order_date) as prev_order
FROM orders;

-- Скользящее среднее
SELECT 
    order_date,
    total,
    AVG(total) OVER (ORDER BY order_date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) as moving_avg
FROM daily_orders;
```

## 8. Работа с JSON

```sql
-- PostgreSQL
SELECT 
    id,
    data->>'name' as name,
    data->>'email' as email
FROM json_table
WHERE data->>'status' = 'active';

-- Вставка JSON
INSERT INTO json_table (data) 
VALUES ('{"name": "John", "email": "john@example.com"}');

-- Обновление JSON
UPDATE json_table 
SET data = jsonb_set(data, '{status}', '"active"')
WHERE id = 1;

-- MySQL
SELECT 
    id,
    JSON_EXTRACT(data, '$.name') as name,
    data->'$.email' as email
FROM json_table
WHERE JSON_EXTRACT(data, '$.status') = 'active';
```

## 9. Полезные функции

### Строковые функции
```sql
-- Конкатенация
SELECT CONCAT(first_name, ' ', last_name) as full_name FROM users;
-- или
SELECT first_name || ' ' || last_name as full_name FROM users;

-- Регистр
SELECT LOWER(username), UPPER(email) FROM users;

-- Подстроки
SELECT SUBSTRING(email, 1, POSITION('@' IN email) - 1) as username FROM users;

-- Трим
SELECT TRIM('  hello  '), LTRIM('  hello'), RTRIM('hello  ');

-- Длина
SELECT LENGTH(username) FROM users;
```

### Дата и время
```sql
-- Текущая дата/время
SELECT NOW(), CURRENT_DATE, CURRENT_TIME;

-- Извлечение частей
SELECT 
    EXTRACT(YEAR FROM created_at) as year,
    EXTRACT(MONTH FROM created_at) as month,
    DATE_PART('dow', created_at) as day_of_week -- PostgreSQL
FROM orders;

-- Форматирование
SELECT DATE_FORMAT(created_at, '%Y-%m-%d') as formatted_date FROM orders; -- MySQL
SELECT TO_CHAR(created_at, 'YYYY-MM-DD') as formatted_date FROM orders; -- PostgreSQL

-- Интервалы
SELECT created_at + INTERVAL '7 DAY' as next_week FROM orders;
SELECT DATE_ADD(created_at, INTERVAL 7 DAY) as next_week FROM orders; -- MySQL
```

### Условные выражения
```sql
-- CASE
SELECT 
    username,
    CASE 
        WHEN age < 18 THEN 'Minor'
        WHEN age BETWEEN 18 AND 65 THEN 'Adult'
        ELSE 'Senior'
    END as age_group
FROM users;

-- COALESCE (первое не NULL значение)
SELECT COALESCE(email, backup_email, 'no-email@example.com') as contact_email FROM users;

-- NULLIF (возвращает NULL если значения равны)
SELECT NULLIF(total, 0) as non_zero_total FROM orders;

-- IF (MySQL)
SELECT IF(total > 100, 'Large', 'Small') as order_size FROM orders;

-- IIF (SQL Server)
SELECT IIF(total > 100, 'Large', 'Small') as order_size FROM orders;
```

## 10. Пагинация

```sql
-- Простая пагинация
SELECT * FROM users 
ORDER BY id 
LIMIT 10 OFFSET 20; -- страница 3 (пропустить 20, взять 10)

-- Пагинация с общим количеством
WITH paginated AS (
    SELECT *, ROW_NUMBER() OVER (ORDER BY id) as row_num
    FROM users
)
SELECT *, (SELECT COUNT(*) FROM users) as total_count
FROM paginated
WHERE row_num BETWEEN 21 AND 30;
```

## 11. Миграции и изменения схемы

```sql
-- Добавление столбца
ALTER TABLE users ADD COLUMN phone VARCHAR(20);

-- Удаление столбца
ALTER TABLE users DROP COLUMN phone;

-- Изменение типа данных
ALTER TABLE users MODIFY COLUMN phone VARCHAR(30); -- MySQL
ALTER TABLE users ALTER COLUMN phone TYPE VARCHAR(30); -- PostgreSQL

-- Переименование таблицы
ALTER TABLE old_name RENAME TO new_name;

-- Добавление ограничения
ALTER TABLE users ADD CONSTRAINT chk_age CHECK (age >= 0);
ALTER TABLE orders ADD FOREIGN KEY (user_id) REFERENCES users(id);

-- Удаление таблицы
DROP TABLE IF EXISTS temp_table;
```

## 12. Рекомендации для разработчиков

### Производительность
1. **Всегда используйте WHERE** - фильтруйте данные на стороне БД
2. **Избегайте SELECT *** - выбирайте только нужные поля
3. **Используйте LIMIT** для больших выборок
4. **Индексы на часто используемых полях** в WHERE, JOIN, ORDER BY
5. **Избегайте N+1 запросов** - используйте JOIN или подзапросы

### Безопасность
```sql
-- НИКОГДА ТАК НЕ ДЕЛАЙТЕ (SQL-инъекция)
-- query = "SELECT * FROM users WHERE username = '" + username + "'"

-- ВСЕГДА используйте параметризованные запросы
-- Пример для Node.js
db.query('SELECT * FROM users WHERE username = ?', [username]);

-- Пример для Python
cursor.execute('SELECT * FROM users WHERE username = %s', (username,))

-- Пример для Java
PreparedStatement stmt = conn.prepareStatement(
    "SELECT * FROM users WHERE username = ?"
);
stmt.setString(1, username);
```

### Мониторинг и логирование
```sql
-- Медленные запросы (MySQL)
SHOW PROCESSLIST;
-- Включение лога медленных запросов
SET GLOBAL slow_query_log = 'ON';

-- План выполнения запроса
EXPLAIN SELECT * FROM users WHERE email = 'test@example.com';

-- Статистика по таблицам
ANALYZE TABLE users; -- MySQL
VACUUM ANALYZE users; -- PostgreSQL
```

## 13. Различия между СУБД

| Операция | PostgreSQL | MySQL | SQLite |
|----------|------------|-------|---------|
| Конкатенация | `||` или `CONCAT()` | `CONCAT()` | `||` |
| LIMIT/OFFSET | `LIMIT 10 OFFSET 20` | `LIMIT 10 OFFSET 20` | `LIMIT 10 OFFSET 20` |
| Верхний регистр | `UPPER()` | `UPPER()` | `UPPER()` |
| Текущее время | `NOW()` | `NOW()` | `CURRENT_TIMESTAMP` |
| Автоинкремент | `SERIAL` | `AUTO_INCREMENT` | `AUTOINCREMENT` |
| Изменить таблицу | `ALTER TABLE` | `ALTER TABLE` | ограничено |
| Тип boolean | `BOOLEAN` | `TINYINT(1)` | `BOOLEAN` |

## 14. Полезные ресурсы

### Практика
- [SQL Fiddle](http://sqlfiddle.com/) - онлайн песочница для SQL
- [LeetCode SQL](https://leetcode.com/problemset/database/) - задачи по SQL
- [SQLZoo](https://sqlzoo.net/) - интерактивные уроки

### Документация
- [PostgreSQL Docs](https://www.postgresql.org/docs/)
- [MySQL Docs](https://dev.mysql.com/doc/)
- [SQLite Docs](https://www.sqlite.org/docs.html)

Этот справочник покрывает основные аспекты SQL, необходимые backend-разработчику. Помните, что конкретный синтаксис может отличаться в зависимости от СУБД, поэтому всегда сверяйтесь с документацией вашей базы данных.