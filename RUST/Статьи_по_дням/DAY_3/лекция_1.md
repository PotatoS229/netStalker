Сегодная мы продолжим разбираться с RUST и изучим в этой лекции тему 
# Концепции владения 
Чесно говоря, я думал, как же объяснить этиу тему, и решил, что лучший способ это просто написать кучу кода с качественными и своевременными коментариями по этой теме, советую заценить, а потом уже самостоятель написать парочку программ

## Немного душной теории
Система владения - это особенность Rust, котораяф обеспечивает безопасность памяти без сборщика мусора. Она основана на трех принципах 
1) У каждого значения в Rust есть владелец
2) В один момент времени может быть один владелец 
3) Когда владелец выходит из области видимости значение удаляется 

А теперь давайте перейдем к примерам 

### Пример по пунктам:
Принцип 1 "У каждого значения есть влаелец"
```rust
fn main(){
    println!("=== Принцип 1: У каждого значения есть владелец ===");

    //Когда мы создаем строку, переменная "s" становится ее владельцем
    let s = String::from("Hello");
    // s владеет данными в куче: ['H','e','l','l','o']
    // В стеке хранится структура String содержащая:
    // - указатель на данные кучи
    // - длину 
    // - умкость

    println!("Владелец s = {}", s);

    // Для примитивных типов (хранящихся в стеке) принцип тот же
    let x = 42; // 'x' владеет значением 42 в стеке
    println!("Владелец: x = {}", x);
}
```

---

Принцип 2 "В один момент времени может быть только один владелец"
```rust
fn main(){
    println!("\n=== Принцип 2: Только один владелец ===");

    // Создадим строку в куче
    let s1 = String::from("RUST");

    //Посмотрим на внутреннее представление 
    println!("s1 = {}", s1); // Значения в куче
    println!("длина s1={}", s1.len()); // Длина
    println!("", s1.capacity); // Размерность
    println!("Адрес указателя s1 = {:p}", s1.as_ptr()); //адресс указателя

    //ПЕРЕМЕЩЕНЕЕ ВЛАДЕНИЯ
    // Когда мы присваиваем s1 переменной s2, происходит перемещение, а не копирование 
    let s2 = s1; // Владение Перемещение от s1 к s2
    
    // s1 Перестает быть валидной
    // Компилятор "инвалидирует" переменную s1
    println!("s2 = '{}'", s2);
    println!("Адрес указателя s2 = {:p}", s2.as_ptr()); // Тот же адрес!
}
```
а теперь у вас вероятнее всего могт возникнуть вопросы почему же, так происходит к чему такая строгость
Данная схема работы предотвращает:
1) Двойное освобождение памяти 
2) Висящие указатели 
3) Гонки данных

---

Принцип 3 " Когда владелец выходит из области видимости, значение удаляется"
```rust
fn main(){
    println!("=== Принцип 3: Область видимости и удаление ===");
    //Создадим внутренный блок(своя область видимости)
    {
        let owner = String::from("Временное значение");
        println!("В области видимости {}", owner);
        //Здесь owner активен
    }
    // а сдесь уже область видимости отсутствует и owner не сущестуетб удалено
}
```
---
!!!
## Теперь все таки время вернуться к теории
Как бы я не хотел бы игнорировать теорию, но без нее не куда 
### Стек и куча
Предлагая окончательно разолбраться с данными понятиями
* Стек - часть памяти, которая хранит значение в том же виде что и получает их, а удаляет в обратном порядке. Стек обизуется хранить в себе определенный обьем, то есть размер фиксированный 
* Куча - это такая же часть памяти, однако Операционная
система находит достаточно большое пустое место в куче, помечает его как исполь-
зуемое и возвращает указатель, являющийся адресом этого места. 
