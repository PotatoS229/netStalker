# Лекция: Управление потоком выполнения в Rust

## Содержание
1. [Введение в управление потоком](#введение)
2. [Условное выполнение с `if`](#условное-выполнение)
3. [Типизация условий](#типизация-условий)
4. [Цепочки условий `else if`](#цепочки-условий)
5. [`if` как выражение](#if-как-выражение)
6. [Циклы в Rust](#циклы-в-rust)
7. [Практические рекомендации](#практические-рекомендации)

---

## Введение в управление потоком {#введение}

Управление потоком выполнения (control flow) — фундаментальная концепция в программировании, позволяющая программам принимать решения и повторять действия. В Rust, как и в других императивных языках, эта возможность реализована через конструкции ветвления и циклов[^1].

> **Ключевой принцип**: Rust следует принципу "явности" (explicitness) — компилятор требует четких указаний о типах и условиях, что предотвращает целые классы ошибок времени выполнения.

## Условное выполнение с `if` {#условное-выполнение}

### Базовый синтаксис

```rust
let number = 7;

if number < 5 {
    println!("условие было истинным");
} else {
    println!("условие было ложным");
}
```

**Механизм работы**:
1. Вычисление выражения условия (`number < 5`)
2. Проверка результата на истинность (`true`/`false`)
3. Выполнение соответствующего блока кода
4. Переход к следующему за конструкцией `if` коду

### Особенности Rust
- **Обязательные фигурные скобки** — в отличие от языков вроде Python, где отступы определяют блоки, Rust требует явного указания границ блоков[^2].
- **Блок `else` опционален** — если условие ложно и блок `else` отсутствует, программа просто переходит к следующему оператору.

## Типизация условий {#типизация-условий}

### Строгая типизация
В Rust условие в `if` **должно** иметь тип `bool`. Это отличие от языков с неявным приведением типов:

```rust
// JavaScript (валидно)
if (3) { console.log("выполнится"); }

// Rust (ошибка компиляции)
let number = 3;
if number {  // ОШИБКА: expected bool, found integer
    println!("число было равно трем");
}
```

**Ошибка компиляции**:
```
error[E0308]: mismatched types
--> src/main.rs:4:8
  |
4 | if number {
  |    ^^^^^^ expected bool, found integral variable
  |
  = note: expected type `bool`
             found type `{integer}`
```

### Философия дизайна
Этот дизайн-выбор отражает философию Rust:
1. **Предотвращение скрытых ошибок** — неявное приведение 0/1 к `false`/`true` может маскировать логические ошибки
2. **Ясность намерений** — программист должен явно указать, какое сравнение он имеет в виду
3. **Безопасность памяти** — строгая типизация помогает компилятору гарантировать безопасность памяти

### Правильный подход
```rust
let number = 3;

// Явное сравнение
if number != 0 {
    println!("число было отличным от нуля");
}

// Другие возможные сравнения
if number > 0 { /* ... */ }
if number == 3 { /* ... */ }
if number % 2 == 0 { /* ... */ }
```

## Цепочки условий `else if` {#цепочки-условий}

### Пример использования
```rust
let number = 6;

if number % 4 == 0 {
    println!("число делится на 4");
} else if number % 3 == 0 {
    println!("число делится на 3");
} else if number % 2 == 0 {
    println!("число делится на 2");
} else {
    println!("число не делится на 4, 3 и 2");
}
// Вывод: "число делится на 3"
```

### Критически важное поведение
- **Проверка сверху вниз** — условия оцениваются последовательно
- **Первое истинное условие побеждает** — выполняется только первый блок с истинным условием
- **Последующие условия игнорируются** — даже если они также истинны

**Важное замечание**: Порядок условий имеет значение! В примере выше, хотя 6 делится и на 2, и на 3, выполняется только блок для деления на 3, так как это условие проверяется раньше.

### Ограничения и альтернативы
```rust
// Неоптимально для многих условий
if x == 1 { /* ... */ }
else if x == 2 { /* ... */ }
else if x == 3 { /* ... */ }
// ... много условий ...

// Лучше использовать match (глава 6)
match x {
    1 => { /* ... */ },
    2 => { /* ... */ },
    3 => { /* ... */ },
    _ => { /* ... */ },
}
```

## `if` как выражение {#if-как-выражение}

### Концепция выражений в Rust
В Rust почти всё является выражением (expression), возвращающим значение. Это включает и конструкцию `if`:

```rust
let condition = true;
let number = if condition {
    5  // Возвращаемое значение блока if
} else {
    6  // Возвращаемое значение блока else
};

println!("Значение числа равно {}", number); // Вывод: 5
```

**Синтаксические требования**:
1. **Отсутствие точки с запятой** в последней строке блока — это возвращаемое значение
2. **Все ветки должны возвращать значения одного типа**
3. **Обязательность блока `else`** при использовании в контексте выражения (если `if` может быть ложным)

### Контраст с императивными языками
```c
// C/C++/Java (оператор, не выражение)
int number;
if (condition) {
    number = 5;
} else {
    number = 6;
}

// Rust (выражение)
let number = if condition { 5 } else { 6 };
```

### Ошибки типизации
```rust
// ОШИБКА КОМПИЛЯЦИИ
let number = if condition {
    5          // тип: i32
} else {
    "шесть"    // тип: &str
};

// Сообщение об ошибке:
// error[E0308]: if and else have incompatible types
// expected type `{integer}`, found type `&str`
```

**Причина**: Компилятор должен знать тип переменной `number` на этапе компиляции для:
- Проверки типов при использовании переменной
- Выделения правильного количества памяти
- Генерации оптимального машинного кода

## Циклы в Rust {#циклы-в-rust}

### Три вида циклов
Rust предоставляет три конструкции для повторения кода:

| Конструкция | Назначение | Бесконечный | С условием | По коллекции |
|-------------|------------|-------------|------------|--------------|
| `loop` | Бесконечный цикл | ✓ | ✗ | ✗ |
| `while` | Цикл с условием | ✗ | ✓ | ✗ |
| `for` | Итерация по коллекции | ✗ | ✗ | ✓ |

### 1. Бесконечный цикл с `loop`
```rust
loop {
    println!("еще раз!");
    // Бесконечное выполнение
    // Требует явного break или сигнала прерывания
}
```

**Прерывание**: `Ctrl+C` в терминале или ключевое слово `break` внутри цикла.

### Возврат значения из `loop`
Уникальная особенность Rust — цикл `loop` может возвращать значение:

```rust
let mut counter = 0;
let result = loop {
    counter += 1;
    
    if counter == 10 {
        break counter * 2;  // Возвращаем значение
    }
};

println!("Результат равен {}", result); // Вывод: 20
```

**Механизм**:
1. Ключевое слово `break` может принимать выражение
2. Это выражение становится возвращаемым значением всего цикла
3. Тип возвращаемого значения должен соответствовать типу переменной

### 2. Условный цикл `while`
```rust
let mut number = 3;

while number != 0 {
    println!("{}!", number);
    number = number - 1;  // или: number -= 1;
}

println!("Поехали!!!");
```

**Эквивалент без `while`** (паттерн, который `while` абстрагирует):
```rust
let mut number = 3;

loop {
    if number != 0 {
        println!("{}!", number);
        number = number - 1;
    } else {
        break;
    }
}
```

### 3. Цикл `for` для итерации
#### Итерация по массиву
```rust
let a = [10, 20, 30, 40, 50];

// Способ 1: while (не рекомендуется)
let mut index = 0;
while index < 5 {
    println!("Значение равно {}", a[index]);
    index += 1;
}

// Способ 2: for (рекомендуется)
for element in a.iter() {
    println!("Значение равно {}", element);
}

// Способ 3: for с деструктуризацией (еще лучше)
for (index, &value) in a.iter().enumerate() {
    println!("Индекс: {}, значение: {}", index, value);
}
```

**Преимущества `for` над `while`**:
1. **Безопасность** — исключены ошибки выхода за границы массива
2. **Производительность** — компилятор может оптимизировать итерацию
3. **Читаемость** — ясное намерение "пройти по всем элементам"
4. **Поддержка изменений** — не нужно обновлять условие при изменении размера коллекции

#### Использование диапазонов (Range)
```rust
// Обратный отсчет с использованием Range
for number in (1..4).rev() {
    println!("{}!", number);
}
println!("Поехали!!!");
```

**Синтаксис диапазонов**:
- `1..4` — от 1 до 3 (исключая 4)
- `1..=4` — от 1 до 4 (включая 4)
- `(1..4).rev()` — обратный порядок: 3, 2, 1

## Практические рекомендации {#практические-рекомендации}

### 1. Выбор между `if` и `match`
```rust
// Используйте if для:
// - Простых условий (1-2 варианта)
// - Нецелочисленных сравнений
// - Сложных логических выражений

// Используйте match для:
// - Множества дискретных значений
// - Сопоставления с образцом (pattern matching)
// - Исчерпывающей проверки всех случаев
```

### 2. Идиоматичный Rust
```rust
// Предпочитайте
let result = if condition { value1 } else { value2 };

// Вместо
let result;
if condition {
    result = value1;
} else {
    result = value2;
}
```

### 3. Обработка циклов
- **Всегда предпочитайте `for`** при итерации по коллекциям
- **Используйте `while`** только когда условие не связано с итерацией
- **`loop` с `break`** для сложных условий выхода

### 4. Производительность
- Циклы `for` обычно наиболее эффективны — компилятор Rust может их векторизовать
- Условия в `if` должны быть простыми для лучшей предсказуемости ветвления
- Избегайте вложенных циклов и условий там, где это возможно

### 5. Читаемость
```rust
// Плохо: сложное вложенное условие
if a {
    if b {
        if c {
            // ...
        }
    }
}

// Лучше: ранний возврат или match
if !a { return; }
if !b { return; }
if !c { return; }
// ...
```

## Заключение

Управление потоком в Rust сочетает мощь с безопасностью. Ключевые отличия от других языков:

1. **Строгая типизация условий** — предотвращает целый класс ошибок
2. **`if` как выражение** — позволяет более функциональный стиль
3. **Безопасные циклы** — идиоматические конструкции предотвращают типичные ошибки
4. **Явность** — компилятор требует четких указаний, что приводит к более надежному коду

Эти особенности делают Rust особенно подходящим для системного программирования, где ошибки управления потоком могут иметь серьезные последствия.

---

[^1]: Императивное программирование — парадигма, в которой программа состоит из последовательности инструкций, изменяющих состояние программы. Rust в основном следует императивной модели, хотя включает элементы функционального программирования.

[^2]: Это решение связано с системой владения (ownership) Rust. Четко определенные блоки помогают компилятору отслеживать время жизни переменных.

[^3]: Диапазоны (Range) в Rust реализованы как итераторы, что позволяет ленивое вычисление и эффективное использование памяти.