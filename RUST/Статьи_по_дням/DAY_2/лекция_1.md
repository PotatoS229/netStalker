# Доброго времени суток! Продолжаем изучение Rust

---

## Управление потоком выполнения в Rust

Управление потоком — это ключевая концепция в программировании, позволяющая программам принимать решения и повторять действия. В Rust эта возможность реализована через ветвления и циклы, как и во многих других языках.

Начнем с условного выполнения.

## Условное выполнение с if

Пример:

```rust
let number = 7;
if number < 5 {
    println!("Условие было true");
} else {
    println!("False");
}
```

А теперь подробнее рассмотрим, как работает программа:

1. Вычисление выражения условия (`number < 5`)
2. Проверка результата на истинность (`true`/`false`)
3. Выполнение соответствующего блока кода
4. Переход к следующему за конструкцией `if` коду

Хочу отметить: для выходцев из Python здесь синтаксис действительно нормальный, без табуляции, поэтому читабельность кода повысится в разы.

---

## Типизация условий

Напомню: Rust был придуман, чтобы частично заменить C++, но сохранить важные и ключевые особенности, за которые любили C++. Поэтому в Rust, как и в других строго типизированных языках, в `if` должно быть помещено значение типа `bool`. Покажу на практике:

```rust
fn main() {
    let number = 3;
    if number {  // Ошибка: ожидается bool
        println!("Good");
    }
}
```

При запуске произойдет ошибка компиляции:

```bash
error[E0308]: mismatched types
--> src/main.rs:4:8
  |
4 | if number {
  |    ^^^^^^ expected bool, found integer
  |
  = note: expected type `bool`
             found type `{integer}`
```

---

## Философия дизайна

1. **Предотвращение скрытых ошибок** — неявное приведение 0/1 к `false`/`true` может маскировать логические ошибки
2. **Ясность намерений** — программист должен явно указать, какое сравнение он имеет в виду
3. **Безопасность памяти** — строгая типизация помогает компилятору гарантировать безопасность памяти

Правильный подход:

```rust
fn main() {
    let number = 3;
    if number != 0 {
        println!("число было отличным от нуля");
    }
    if number > 0 { /* ... */ }
    if number == 3 { /* ... */ }
    if number % 2 == 0 { /* ... */ }
}
```

Так же в Rust присутствует цепочка `else if`:

```rust
let number = 6;

if number % 4 == 0 {
    println!("число делится на 4");
} else if number % 3 == 0 {
    println!("число делится на 3");
} else if number % 2 == 0 {
    println!("число делится на 2");
} else {
    println!("число не делится на 4, 3 и 2");
}
// Вывод: "число делится на 3"
```

**Критически важное поведение:**

- Проверка сверху вниз — условия оцениваются последовательно
- Первое истинное условие побеждает — выполняется только первый блок с истинным условием
- Последующие условия игнорируются — даже если они также истинны

**Важное замечание:** Порядок условий имеет значение! В примере выше, хотя 6 делится и на 2, и на 3, выполняется только блок для деления на 3, так как это условие проверяется раньше.

Однако вы заметили: это же неудобно, приходится вечно писать `else if`, это долго и муторно. Поэтому сделаем круче с помощью `match`:

```rust
let number = 6;
match number {
    1 => println!("False"),
    2 => println!("False"),
    3 => println!("False"),
    4 => println!("False"),
    5 => println!("False"),
    6 => println!("True"),
    _ => println!("Другое число"),
}
```

Так же покажу вам фишку, которая наверняка в будущем поможет:

```rust
let condition = true;
let number = if condition {
    5
} else {
    6
};
println!("Значение числа равно {}", number);
```

**Синтаксические требования:**

- Отсутствие точки с запятой в последней строке блока — это возвращаемое значение
- Все ветки должны возвращать значения одного типа
- Обязательность блока `else` при использовании в контексте выражения (если `if` может быть ложным)

Для людей, знающих C/C++/Java, это покажется странным, так как мы привыкли к другому, но этот метод вы полюбите:

```rust
let number = if true { 5 } else { 6 };
```

```cpp
// Для сравнения с C++
int num;
if (true) {
    num = 5;
} else {
    num = 6;
}
```

---

## Циклы

Это вообще must-have в программировании, так как никого не обрадует необходимость сотни раз выполнять одно и то же действие, а циклы решают данную проблему.

| Конструкция | Назначение           | Бесконечный | С условием | По коллекции |
|-------------|----------------------|-------------|------------|--------------|
| `loop`      | Бесконечный цикл     | ✓           | ✗          | ✗            |
| `while`     | Цикл с условием      | ✗           | ✓          | ✗            |
| `for`       | Итерация по коллекции| ✗           | ✗          | ✓            |

А теперь рубрика "эксперименты":

```rust
loop {
    println!("еще раз!");
    // Бесконечное выполнение
    // Требует явного break или сигнала прерывания
}
```

```rust
let mut counter = 0;
let result = loop {
    counter += 1;
    
    if counter == 10 {
        break counter * 2;  // Возвращаем значение
    }
};

println!("Результат равен {}", result); // Вывод: 20
```

```rust
let mut number = 3;

while number != 0 {
    println!("{}!", number);
    number -= 1;
}

println!("Поехали!!!");
```

```rust
let mut number = 3;

loop {
    if number != 0 {
        println!("{}!", number);
        number -= 1;
    } else {
        break;
    }
}
```

```rust
let a = [10, 20, 30, 40, 50];

// Способ 1: while (не рекомендуется)
let mut index = 0;
while index < 5 {
    println!("Значение равно {}", a[index]);
    index += 1;
}

// Способ 2: for (рекомендуется)
for element in a.iter() {
    println!("Значение равно {}", element);
}

// Способ 3: for с деструктуризацией (еще лучше)
for (index, &value) in a.iter().enumerate() {
    println!("Индекс: {}, значение: {}", index, value);
}
```

В целом не вижу смысла объяснять код сверху, просто прочитайте комментарии.

А теперь посмотрим на мой любимый способ:

```rust
for number in (1..4).rev() {
    println!("{}!", number);
}
```

- `1..4` — от 1 до 3 (исключая 4)
- `1..=4` — от 1 до 4 (включая 4)
- `(1..4).rev()` — обратный порядок: 3, 2, 1

---

## Практические рекомендации

**Используйте `if` для:**
- Простых условий (1-2 варианта)
- Нецелочисленных сравнений
- Сложных логических выражений

**Используйте `match` для:**
- Множества дискретных значений
- Сопоставления с образцом (pattern matching)
- Исчерпывающей проверки всех случаев

## Идиоматичный Rust

**Предпочитайте:**
```rust
let result = if condition { value1 } else { value2 };
```

**Вместо:**
```rust
let result;
if condition {
    result = value1;
} else {
    result = value2;
}
```

## Производительность

- Циклы `for` обычно наиболее эффективны — компилятор Rust может их векторизовать
- Условия в `if` должны быть простыми для лучшей предсказуемости ветвления
- Избегайте вложенных циклов и условий там, где это возможно