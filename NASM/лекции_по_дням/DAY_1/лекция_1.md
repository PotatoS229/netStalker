# Доброе утро! Добро пожаловать в курс по изучению NASM

## Что такое NASM?
**NASM** (Netwide Assembler) — это популярный ассемблер для архитектур x86 и x86-64. Он преобразует человекочитаемый ассемблерный код в машинные инструкции (объектный код), который затем может быть скомпонован в исполняемый файл.

## Машинные инструкции
Программы состоят из инструкций, которые интерпретирует процессор. Каждая команда имеет числовое представление (машинный код).

**Пример:**
- `C7` в шестнадцатеричной системе (или `11000111` в двоичной) может означать операцию "переместить значение в память" в определенном контексте для x86-64
- `B8` в шестнадцатеричной системе может означать "переместить непосредственное значение в регистр EAX"

> **Важно:** Конкретное значение этих кодов зависит от контекста и последующих байтов. Приведенные примеры упрощены для понимания концепции.

Для облегчения работы программистов используются мнемонические команды:
```nasm
mov rax, 1    ; Для 64-битной архитектуры
mov eax, 1    ; Для 32-битной архитектуры
```

## Как процессор исполняет команды
Процессор использует цикл выборки и выполнения (Fetch-Execute Cycle):

1. **Выборка:** Получает инструкцию по адресу, указанному в регистре RIP (Instruction Pointer)
2. **Декодирование:** Расшифровывает, какая операция требуется
3. **Инкремент:** Увеличивает указатель на следующую инструкцию
4. **Выполнение:** Выполняет декодированную операцию
5. **Повторение:** Возвращается к шагу 1

## Регистры процессора
Регистры — это сверхбыстрая память внутри процессора, используемая для временного хранения данных и управления выполнением программ.

### Основные группы регистров x86-64:
1. **Регистры общего назначения** — для вычислений и обработки данных
2. **Специализированные регистры** — для конкретных задач (например, FPU, SSE, AVX)
3. **Сегментные регистры** — в основном для обратной совместимости
4. **Служебные регистры** — управление процессором (RIP, RFLAGS)

### Универсальные регистры общего назначения (64-битные):

| 64-бит | 32-бит | 16-бит | 8-бит (младшая) | 8-бит (старшая) | Назначение |
|--------|--------|--------|-----------------|-----------------|------------|
| RAX    | EAX    | AX     | AL              | AH              | Аккумулятор, возврат значений |
| RBX    | EBX    | BX     | BL              | BH              | Базовый регистр |
| RCX    | ECX    | CX     | CL              | CH              | Счетчик (циклы) |
| RDX    | EDX    | DX     | DL              | DH              | Данные, дополнительный аккумулятор |
| RSI    | ESI    | SI     | SIL             | -               | Указатель источника (строковые операции) |
| RDI    | EDI    | DI     | DIL             | -               | Указатель назначения (строковые операции) |
| RBP    | EBP    | BP     | BPL             | -               | Указатель базы стека |
| RSP    | ESP    | SP     | SPL             | -               | Указатель вершины стека |
| R8-R15 | R8D-R15D | R8W-R15W | R8B-R15B    | -               | Дополнительные регистры (x86-64) |

### Регистр флагов (RFLAGS)
Содержит биты, отражающие состояние процессора и результаты операций:

| Позиция | Флаг | Обозначение | Назначение |
|---------|------|-------------|------------|
| 0       | CF   | Carry Flag | Флаг переноса: устанавливается при переполнении беззнаковой арифметики |
| 2       | PF   | Parity Flag | Флаг четности: 1 если четное число единиц в младшем байте |
| 4       | AF   | Auxiliary Carry | Флаг вспомогательного переноса (для BCD-арифметики) |
| 6       | ZF   | Zero Flag | Флаг нуля: 1 если результат операции равен нулю |
| 7       | SF   | Sign Flag | Флаг знака: 1 если результат отрицательный |
| 8       | TF   | Trap Flag | Флаг трассировки (для отладки) |
| 9       | IF   | Interrupt Flag | Флаг прерываний: разрешает маскируемые прерывания |
| 10      | DF   | Direction Flag | Флаг направления строковых операций (0=вперед, 1=назад) |
| 11      | OF   | Overflow Flag | Флаг переполнения знаковой арифметики |

## Установка NASM в Linux

### Для Ubuntu/Debian:
```bash
sudo apt update
sudo apt install -y nasm
nasm -v  # Проверка установки
```

### Для Arch Linux:
```bash
sudo pacman -S nasm
nasm -v   # Проверка установки
```

## Первая программа на NASM

Создайте файл `hello.asm`:

```nasm
global _start          ; Объявляем точку входа как глобальную

section .text          ; Секция кода
_start:                ; Точка входа программы
    mov rax, 60        ; Номер системного вызова exit (60 для x86-64 Linux)
    mov rdi, 42        ; Код возврата программы (передается ОС)
    syscall            ; Вызов ядра
```

### Объяснение кода:
1. **global _start** — указывает линкеру, что метка `_start` является точкой входа
2. **section .text** — секция, содержащая исполняемый код
3. **_start:** — метка точки входа программы
4. **mov rax, 60** — загружает номер системного вызова (60 = exit)
5. **mov rdi, 42** — устанавливает код возврата программы
6. **syscall** — выполняет системный вызов ядра

### Компиляция и запуск:
```bash
# Ассемблирование
nasm -f elf64 hello.asm -o hello.o

# Линковка
ld hello.o -o hello

# Запуск
./hello

# Проверка кода возврата
echo $?  # Должно вывести 42
```

## Программа с выводом текста

Создайте файл `print.asm`:

```nasm
global _start

section .data
    ; Определение строки с переводом строки
    msg: db "Hello NASM!!!", 0xA  ; 0xA = \n (новая строка)
    len: equ $ - msg              ; Вычисление длины строки

section .text
_start:
    ; Системный вызов write(1, msg, len)
    mov rax, 1          ; 1 = номер системного вызова write
    mov rdi, 1          ; 1 = файловый дескриптор (stdout)
    mov rsi, msg        ; Адрес строки для вывода
    mov rdx, len        ; Длина строки
    syscall             ; Вызов ядра

    ; Системный вызов exit(0)
    mov rax, 60         ; 60 = номер системного вызова exit
    xor rdi, rdi        ; Обнуляем rdi (код возврата = 0)
    syscall             ; Вызов ядра
```

### Объяснение:
1. **section .data** — секция для инициализированных данных
2. **msg: db ...** — определение строки с автоматическим добавлением перевода строки
3. **len: equ $ - msg** — вычисление длины строки ($ = текущая позиция)
4. **xor rdi, rdi** — эффективный способ обнуления регистра (rdi = rdi ⊕ rdi)

### Сборка и запуск:
```bash
# Компиляция и линковка
nasm -f elf64 print.asm -o print.o
ld print.o -o print

# Запуск
./print

# Или одной командой
nasm -f elf64 print.asm && ld print.o -o print && ./print && rm print.o
```

## Инструкция MOV

Инструкция `mov` копирует данные из источника в назначение.

### Синтаксис:
```nasm
mov назначение, источник
```

### Допустимые формы:
1. **Регистр → Регистр**
   ```nasm
   mov rax, rbx      ; Копировать RBX в RAX
   ```

2. **Непосредственное значение → Регистр**
   ```nasm
   mov rax, 42       ; Загрузить число 42 в RAX
   ```

3. **Память → Регистр** (косвенная адресация)
   ```nasm
   mov rax, [rbx]    ; Загрузить значение по адресу в RBX
   ```

4. **Регистр → Память**
   ```nasm
   mov [rbx], rax    ; Сохранить RAX по адресу в RBX
   ```

5. **Непосредственное значение → Память**
   ```nasm
   mov qword [rbx], 42 ; Записать 42 по адресу в RBX
   ```

### Важные ограничения:
- Нельзя копировать память в память напрямую
- Нельзя копировать между регистрами разных размеров (кроме случаев с расширением)
- Размер операндов должен быть согласован

### Примеры с различными размерами:
```nasm
mov rax, 0x123456789ABCDEF0  ; 64-битная запись
mov eax, 0x12345678          ; 32-битная запись (обнуляет старшие 32 бита RAX)
mov ax, 0x1234               ; 16-битная запись
mov al, 0x12                 ; 8-битная запись
```

## Практические советы для начинающих

1. **Комментируйте код:** NASM использует точку с запятой для комментариев
2. **Используйте отступы:** Для улучшения читаемости
3. **Проверяйте размеры:** Следите за согласованностью размеров операндов
4. **Изучите системные вызовы:** Для Linux используйте `man 2 syscalls`
5. **Используйте отладчик:** GDB с расширением для ассемблера незаменим для отладки

## Полезные команды для работы

```bash
# Просмотр системных вызовов
cat /usr/include/x86_64-linux-gnu/asm/unistd_64.h | grep "define __NR"

# Отладка с GDB
gdb ./program
(gdb) layout asm
(gdb) starti
(gdb) ni  # следующая инструкция
```

## Следующие шаги в изучении

После освоения базовых концепций рекомендуется изучить:
1. **Арифметические операции** (add, sub, mul, div)
2. **Логические операции** (and, or, xor, not)
3. **Управление потоком** (jmp, cmp, условные переходы)
4. **Работу со стеком** (push, pop, call, ret)
5. **Функции и соглашения о вызовах** (cdecl, System V ABI)

Удачи в изучении NASM! Помните, что практика — ключ к пониманию ассемблера. Начните с простых программ и постепенно усложняйте задачи.