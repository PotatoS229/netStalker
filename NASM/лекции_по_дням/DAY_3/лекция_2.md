# Инструкция CMP (сравнение)

## Основное назначение
Инструкция `cmp` (Compare) используется для сравнения двух операндов в ассемблере NASM. Она выполняет вычитание второго операнда из первого, **не сохраняя результат операции**, но при этом устанавливает флаги в регистре состояния `RFLAGS` (или `EFLAGS` в 32-битном режиме).

## Синтаксис
```nasm
cmp операнд_1, операнд_2  ; операнд_1 - операнд_2
```

## Как работает CMP
Фактически, `cmp` выполняет операцию вычитания:
```
temp = операнд_1 - операнд_2
```
Но значение `temp` нигде не сохраняется. Вместо этого обновляются флаги в соответствии с результатом этого "виртуального" вычитания.

## Влияние на флаги
Инструкция `cmp` влияет на следующие флаги:

### 1. **ZF (Zero Flag) - Флаг нуля**
- Устанавливается в 1, если операнды равны (результат вычитания равен нулю)
- Сбрасывается в 0, если операнды не равны

### 2. **CF (Carry Flag) - Флаг переноса**
- Устанавливается в 1, если произошел заем (когда операнд_2 > операнд_1 при беззнаковом сравнении)
- Сбрасывается в 0, если заема не было

### 3. **SF (Sign Flag) - Флаг знака**
- Устанавливается в 1, если результат отрицательный (старший бит = 1)
- Сбрасывается в 0, если результат положительный или нулевой

### 4. **OF (Overflow Flag) - Флаг переполнения**
- Устанавливается в 1, если произошло переполнение при знаковом вычитании
- Сбрасывается в 0, если переполнения не было

### 5. **PF (Parity Flag) - Флаг четности**
- Устанавливается в зависимости от четности младшего байта результата
- Реже используется в условных переходах

### 6. **AF (Auxiliary Carry Flag) - Вспомогательный флаг переноса**
- Используется для двоично-десятичной арифметики (BCD)

## Условные переходы на основе CMP

После выполнения `cmp` можно использовать условные переходы для ветвления программы:

### Сравнение на равенство
| Инструкция | Условие перехода | Описание |
|------------|------------------|----------|
| `je`/`jz`  | ZF = 1 | Переход, если равны |
| `jne`/`jnz` | ZF = 0 | Переход, если не равны |

### Беззнаковое сравнение (для адресов, флагов, данных без знака)
| Инструкция | Условие перехода | Описание |
|------------|------------------|----------|
| `ja`/`jnbe` | CF = 0 и ZF = 0 | Выше/больше (above) |
| `jae`/`jnb` | CF = 0 | Выше или равно |
| `jb`/`jnae` | CF = 1 | Ниже/меньше (below) |
| `jbe`/`jna` | CF = 1 или ZF = 1 | Ниже или равно |

### Знаковое сравнение (для чисел со знаком)
| Инструкция | Условие перехода | Описание |
|------------|------------------|----------|
| `jg`/`jnle` | SF = OF и ZF = 0 | Больше (greater) |
| `jge`/`jnl` | SF = OF | Больше или равно |
| `jl`/`jnge` | SF ≠ OF | Меньше (less) |
| `jle`/`jng` | SF ≠ OF или ZF = 1 | Меньше или равно |

## Примеры использования

### Пример 1: Простое сравнение чисел
```nasm
section .text
global _start

_start:
    mov rax, 10
    mov rbx, 20
    cmp rax, rbx      ; Сравниваем RAX и RBX
    
    jl less_than      ; Если RAX < RBX (знаковое сравнение)
    jg greater_than   ; Если RAX > RBX (знаковое сравнение)
    
    ; Если равны
    mov rdi, 0
    jmp exit

less_than:
    mov rdi, 1
    jmp exit

greater_than:
    mov rdi, 2

exit:
    mov rax, 60       ; Системный вызов exit
    syscall
```

### Пример 2: Проверка диапазона
```nasm
section .text
global _start

_start:
    mov rcx, 50
    
    ; Проверяем, находится ли RCX в диапазоне [10, 100]
    cmp rcx, 10
    jl out_of_range   ; Если меньше 10
    
    cmp rcx, 100
    jg out_of_range   ; Если больше 100
    
    ; В диапазоне
    mov rdi, 1
    jmp exit

out_of_range:
    mov rdi, 0

exit:
    mov rax, 60
    syscall
```

### Пример 3: Сравнение строк
```nasm
section .data
    str1 db 'Hello', 0
    str2 db 'World', 0
    str3 db 'Hello', 0

section .text
global _start

_start:
    ; Сравнение первых символов строк
    mov al, [str1]
    mov bl, [str2]
    cmp al, bl
    
    je same_first_char
    ; ... обработка разных символов
    jmp exit

same_first_char:
    ; ... дальнейшая проверка строк
    mov rdi, 1

exit:
    mov rax, 60
    syscall
```

## Важные особенности

### 1. **Размер операндов**
```nasm
cmp byte [var], 10    ; Сравнение байта
cmp word [var], 100   ; Сравнение слова (2 байта)
cmp dword [var], 500  ; Сравнение двойного слова (4 байта)
cmp qword [var], 1000 ; Сравнение учетверенного слова (8 байт)
```

### 2. **Сравнение с непосредственным значением**
```nasm
cmp rax, 100          ; Сравнение регистра с числом
cmp [mem_var], 50     ; Сравнение ячейки памяти с числом
```

### 3. **Комбинация с другими инструкциями**
```nasm
; Частая комбинация: сравнение + переход
test rax, rax         ; Устанавливает флаги как cmp rax, 0
jnz not_zero          ; Переход, если не ноль

; Декремент и проверка на ноль
dec rcx
jnz loop_start        ; Продолжать цикл, пока RCX != 0
```

## Практическое применение

### Циклы
```nasm
mov rcx, 10          ; Счетчик цикла
loop_start:
    ; ... тело цикла
    
    dec rcx          ; Уменьшаем счетчик
    cmp rcx, 0       ; Сравниваем с нулем
    jne loop_start   ; Продолжаем, если не ноль
```

### Условные операции
```nasm
cmp rax, rbx
cmovg rcx, rdx       ; Условное перемещение: если RAX > RBX, то RCX = RDX
```

### Проверка границ
```nasm
; Проверка, что индекс в допустимых пределах
cmp rsi, array_size
jae out_of_bounds    ; Если индекс >= размера массива
```

## Отладка и диагностика

При отладке программ с `cmp` полезно знать:
1. После `cmp` проверяйте флаги в отладчике
2. Используйте `test` для быстрой проверки на ноль
3. Помните о различии знаковых и беззнаковых сравнений
4. Проверяйте размеры операндов - несоответствие размеров может привести к ошибкам

## Типичные ошибки

1. **Путаница между знаковыми и беззнаковыми сравнениями**:
```nasm
mov rax, -1
mov rbx, 1
cmp rax, rbx
jb below              ; Сработает неправильно для знаковых чисел!
jl less               ; Правильно для знаковых чисел
```

2. **Забытое сравнение перед переходом**:
```nasm
; НЕПРАВИЛЬНО:
mov rax, 10
je equal              ; Этот переход никогда не сработает!

; ПРАВИЛЬНО:
mov rax, 10
cmp rax, 10
je equal
```

Инструкция `cmp` является фундаментальной для реализации условной логики в ассемблере. Правильное понимание ее работы с флагами и условными переходами критически важно для написания корректного и эффективного низкоуровневого кода.