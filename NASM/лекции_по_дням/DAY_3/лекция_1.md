# Условные переходы в NASM и работа с флагами

В прошлой лекции мы изучили, как производить переходы при помощи `jmp`, но в NASM кроме безусловного перехода присутствует и набор условных переходов, которые зависят от состояния определенных флагов в регистре **RFLAGS**. Данные флаги меняются после выполнения арифметических и логических операций и играют ключевую роль в организации ветвлений и циклов.

## Основные флаги и их состояния

В регистре RFLAGS выделяются несколько бит, которые называются флагами состояния. Они отражают результат последних вычислений и влияют на то, будет ли выполнен переход.

Давайте взглянем на них подробнее:

1. **CF (Carry Flag)** - флаг переноса - устанавливается, если происходит беззнаковое переполнение, например при сложении 0xFF и 0x01
2. **OF (Overflow Flag)** - флаг переполнения - сигнализирует о знаковом переполнении, когда результат выходит за рамки представления знакового числа
3. **SF (Sign Flag)** - флаг знака - копирует старший бит результата, если он равен 1, значит результат отрицательный
4. **ZF (Zero Flag)** - флаг нуля - устанавливается, если результат равен нулю

**Важно:** Флаги изменяются только после операций, влияющих на вычисления (`add`, `sub`, `inc`, `dec`, `and`, `xor`, `or`), а к примеру `mov` и `lea` на флаги не влияют.

## Инструкции условного перехода

Каждая из инструкций проверяет определенное состояние флага и при его выполнении осуществляется переход к указанной метке:

### Флаговые переходы:

| Инструкция | Условие перехода | Описание |
|------------|------------------|----------|
| `jc`  | CF = 1 | Переход, если был перенос |
| `jnc` | CF = 0 | Переход, если не было переноса |
| `jo`  | OF = 1 | Переход, если было переполнение |
| `jno` | OF = 0 | Переход, если не было переполнения |
| `js`  | SF = 1 | Переход, если результат отрицательный |
| `jns` | SF = 0 | Переход, если результат положительный |
| `jz`  | ZF = 1 | Переход, если результат ноль |
| `jnz` | ZF = 0 | Переход, если результат не ноль |

### Сравнения для беззнаковых чисел:

| Инструкция | Условие перехода | Описание |
|------------|------------------|----------|
| `ja`  | CF = 0 и ZF = 0 | Переход, если первый операнд > второго |
| `jae` | CF = 0 | Переход, если первый операнд ≥ второго |
| `jb`  | CF = 1 | Переход, если первый операнд < второго |
| `jbe` | CF = 1 или ZF = 1 | Переход, если первый операнд ≤ второго |

### Сравнения для знаковых чисел:

| Инструкция | Условие перехода | Описание |
|------------|------------------|----------|
| `jg`  | SF = OF и ZF = 0 | Переход, если первый операнд > второго |
| `jge` | SF = OF | Переход, если первый операнд ≥ второго |
| `jl`  | SF ≠ OF | Переход, если первый операнд < второго |
| `jle` | SF ≠ OF или ZF = 1 | Переход, если первый операнд ≤ второго |

### Равенства (работают для обоих типов):

| Инструкция | Условие перехода | Описание |
|------------|------------------|----------|
| `je`  | ZF = 1 | Переход, если операнды равны |
| `jne` | ZF = 0 | Переход, если операнды не равны |

## Примеры программ

### Пример 1: Работа с флагом переноса (CF)

```nasm
section .text
global _start

_start:
    mov al, 0xFF      ; Максимальное значение для AL - 8 бит
    add al, 3         ; Производим переполнение (0xFF + 3 = 0x102)
    jc метка_перенос  ; Переход, если CF установлен 
    mov rdi, 2        ; выполнится, если CF=0
    jmp завершение 

метка_перенос:
    mov rdi, 4        ; Выполнится, если CF = 1
завершение:
    mov rax, 60       ; exit
    syscall
```

**Разбор примера 1:**

1. **Структура программы:**
   - `section .text` - секция кода
   - `global _start` - объявляем точку входа глобальной

2. **Основная часть программы:**
   - `mov al, 0xFF` - копируем 255 (максимальное 8-битное значение) в регистр AL
   - `add al, 3` - AL = AL + 3, происходит переполнение 8-битного регистра

3. **Флаги после `add al, 3`:**
   - CF = 1 (произошел перенос за пределы 8 бит)
   - ZF = 0 (результат не ноль)
   - SF = 0 (старший бит результата = 0)
   - OF = 0 (нет переполнения знакового числа)

4. **Условный переход:**
   - `jc метка_перенос` - переход выполняется, так как CF = 1
   - Механизм: процессор проверяет CF, если =1 → переход на метку

5. **Регистры:**
   - AL - младшие 8 бит регистра RAX
   - RDI - 64-битный регистр для параметров системных вызовов
   - RAX - 64-битный регистр, хранит номер системного вызова

### Пример 2: Работа с флагом нуля (ZF)

```nasm
section .text
global _start

_start:
    mov rdx, 7      ; копируем в rdx 7
    mov rcx, 7      ; копируем в rcx 7
    sub rdx, rcx    ; rdx = rdx - rcx
    jz ноль         ; переход если ZF = 1 (результат = 0)
    mov rdi, 1      ; выполнится если ZF = 0
    jmp выход

ноль:
    mov rdi, 9      ; выполнится если ZF = 1

выход:
    mov rax, 60     ; exit
    syscall
```

**Разбор примера 2:**

1. **Операция вычитания:**
   - `sub rdx, rcx` = 7 - 7 = 0
   - Устанавливается ZF = 1 (результат равен нулю)

2. **Условный переход:**
   - `jz ноль` - переход выполняется, так как ZF = 1

3. **Результат:**
   - Программа завершится с кодом возврата 9

### Пример 3: Организация цикла

```nasm
section .text
global _start

_start:
    mov rcx, 4      ; Счетчик итераций
    xor rdi, rdi    ; Обнуляем rdi

повтор:
    add rdi, 5      ; увеличиваем rdi на 5
    dec rcx         ; уменьшаем счетчик
    jnz повтор      ; если ZF = 0 (rcx ≠ 0) → продолжать цикл

    mov rax, 60     ; exit
    syscall
```

**Разбор примера 3:**

1. **Инициализация:**
   - `mov rcx, 4` - устанавливаем счетчик цикла
   - `xor rdi, rdi` - обнуляем аккумулятор (идиома для mov rdi, 0)

2. **Тело цикла:**
   - `add rdi, 5` - добавляем 5 к аккумулятору
   - `dec rcx` - уменьшаем счетчик, устанавливает ZF = 1 когда RCX = 0
   - `jnz повтор` - переход если ZF = 0 (счетчик еще не ноль)

3. **Математика цикла:**
   - Цикл выполнится 4 раза
   - RDI = 4 × 5 = 20
   - Программа завершится с кодом возврата 20

## Управление флагами вручную

Иногда требуется управлять флагами вручную. Для этого используются специальные инструкции:

| Инструкция | Описание |
|------------|----------|
| `clc` | Clear Carry - сбрасывает флаг CF (устанавливает в 0) |
| `stc` | Set Carry - устанавливает флаг CF (устанавливает в 1) |
| `cmc` | Complement Carry - инвертирует флаг CF |
| `lahf` | Load AH from Flags - сохраняет младшие 8 бит флагов в регистр AH |
| `sahf` | Store AH into Flags - восстанавливает флаги из регистра AH |

### Пример ручного управления флагами:

```nasm
section .text
global _start

_start:
    clc             ; CF = 0
    stc             ; CF = 1
    jc carry_set    ; переход выполнится
    
    mov rdi, 1
    jmp exit
    
carry_set:
    mov rdi, 2      ; выполнится эта ветка
    
exit:
    mov rax, 60
    syscall
```

## Важные нюансы

1. **Порядок операций влияет на флаги:** Флаги устанавливаются только последней арифметической/логической операцией.

2. **Разные инструкции по-разному влияют на флаги:**
   - `inc` и `dec` не изменяют CF
   - `add` и `sub` изменяют все флаги
   - `mov` не изменяет флаги

3. **Для сравнения чисел:** Обычно используют `cmp` (вычитание без сохранения результата), который устанавливает флаги как `sub`:
   ```nasm
   cmp rax, rbx     ; устанавливает флаги как rax - rbx
   jg больше        ; переход если rax > rbx (знаковое сравнение)
   ```

4. **Эффективность:** Условные переходы могут значительно влиять на производительность из-за предсказания переходов в современных процессорах.

Эта лекция дает фундаментальное понимание работы условных переходов в NASM, что является основой для создания сложных алгоритмов и структур управления потоком выполнения в ассемблере x86-64.