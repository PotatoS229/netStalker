# Подробный разбор программы "Угадайка" на NASM для архитектуры x86-64

## Архитектурные особенности x86-64

Прежде чем разбирать программу, важно понять особенности архитектуры:
- **64-битная архитектура**: использует 64-битные регистры (rax, rdi, rsi и т.д.)
- **Регистры общего назначения**: rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp, r8-r15
- **Соглашения о вызовах**: В Linux системные вызовы используют:
  - rax - номер системного вызова
  - rdi - первый аргумент
  - rsi - второй аргумент  
  - rdx - третий аргумент
- **Маленький порядок байтов (little-endian)**: младший байт по младшему адресу

## Структура программы

### Секция .data (Данные)

```assembly
section .data
    prompt: db "Введите число: ", 0
    prompt_len: equ $ - prompt
```

- `prompt:` - метка, указывающая на начало строки
- `db` - директива для определения байтов (define bytes)
- `"Введите число: ", 0` - строка с завершающим нулем (0 - терминирующий байт)
- `prompt_len: equ $ - prompt` - вычисление длины строки:
  - `$` - текущий адрес (адрес после строки)
  - `prompt` - адрес начала строки
  - `equ` - директива для создания константы времени компиляции

```assembly
    buffer times 256 db 0
```

- `times 256` - повторить 256 раз
- `db 0` - определить байт со значением 0
- Итог: создается буфер из 256 нулевых байтов для хранения ввода пользователя

```assembly
    secret_number equ 42
```

- Константа времени компиляции со значением 42 (загаданное число)
- Не занимает место в памяти, подставляется при компиляции

```assembly
    msg_max: db "Это число большое", 0xA
    len_max: equ $ - msg_max
```

- `0xA` - символ новой строки (LF - line feed)
- Аналогично для других сообщений (msg_equal, msg_min, msg_invalid)

### Секция .text (Код)

#### Функция print_string

```assembly
print_string:
    ; Вызываем sys_write
    mov rax, 1          ; номер системного вызова sys_write
    mov rdi, 1          ; файловый дескриптор stdout
    mov rsi, [rsp + 8]  ; адрес строки (передается первым аргументом)
    mov rdx, [rsp + 16] ; длина строки (передается вторым аргументом)
    syscall 
    ret
```

**Регистры и их назначение:**
- `rax = 1` - номер системного вызова write (sys_write)
- `rdi = 1` - файловый дескриптор (1 = стандартный вывод)
- `rsi` - адрес строки для вывода
  - `[rsp + 8]` - берет адрес строки из стека (первый аргумент)
  - rsp - указатель стека
- `rdx` - длина строки для вывода
  - `[rsp + 16]` - берет длину из стека (второй аргумент)
- `syscall` - инструкция для вызова ядра ОС
- `ret` - возврат из функции

**Работа со стеком:**
- После `call` в стек помещается адрес возврата (8 байт)
- Аргументы передаются через стек: сначала строка (rsp+8), потом длина (rsp+16)

#### Функция read_input

```assembly
read_input:
    mov rax, 0          ; номер системного вызова sys_read
    mov rdi, 0          ; файловый дескриптор stdin
    mov rsi, [rsp + 8]  ; адрес буфера
    mov rdx, 256        ; максимальная длина
    syscall
    ret
```

**Регистры:**
- `rax = 0` - номер системного вызова read (sys_read)
- `rdi = 0` - файловый дескриптор (0 = стандартный ввод)
- `rsi` - адрес буфера для чтения
- `rdx = 256` - максимальное количество байтов для чтения
- Возвращает в rax количество фактически прочитанных байтов

#### Функция string_to_int

```assembly
string_to_int:
    ; Вход: rdi - адрес строки
    ; Выход: rax - число, -1 при ошибке
    
    xor rax, rax        ; обнуляем результат
    xor rcx, rcx        ; обнуляем счетчик
    mov rsi, 10         ; основание системы счисления
    
.convert_loop:
    movzx r8, byte [rdi + rcx] ; загружаем следующий символ
    cmp r8, 0xA         ; проверяем на символ новой строки
    je .done
    cmp r8, 0           ; проверяем на конец строки
    je .done
    cmp r8, '0'         ; проверяем, что символ цифра
    jl .error
    cmp r8, '9'
    jg .error
    
    sub r8, '0'         ; преобразуем символ в цифру
    imul rax, rsi       ; умножаем текущий результат на 10
    add rax, r8         ; добавляем новую цифру
    inc rcx             ; переходим к следующему символу
    jmp .convert_loop
```

**Алгоритм преобразования строки в число (ASCII to integer):**

1. **Инициализация:**
   - `xor rax, rax` - обнуление rax (результат)
     - XOR регистра с самим собой дает 0
   - `xor rcx, rcx` - обнуление rcx (счетчик позиции в строке)
   - `mov rsi, 10` - основание десятичной системы

2. **Цикл преобразования:**
   - `movzx r8, byte [rdi + rcx]` - загрузка символа:
     - `movzx` - move with zero extend (копирует байт в регистр, обнуляя старшие биты)
     - `byte` - размер операнда (1 байт)
     - `[rdi + rcx]` - адресная арифметика: адрес строки + смещение

3. **Проверки:**
   - `cmp r8, 0xA` - проверка на символ новой строки
   - `cmp r8, 0` - проверка на конец строки (нуль-терминатор)
   - `cmp r8, '0'` и `cmp r8, '9'` - проверка, что символ между '0' и '9'

4. **Преобразование цифры:**
   - `sub r8, '0'` - преобразование ASCII в число:
     - ASCII '0' = 48, '1' = 49, поэтому '1' - '0' = 1

5. **Накопление результата:**
   - `imul rax, rsi` - rax = rax * 10
     - imul - знаковое умножение
   - `add rax, r8` - добавление новой цифры
   - `inc rcx` - увеличение счетчика

### Основная программа (_start)

```assembly
_start:
.game_loop:
    ; Выводим приглашение для ввода
    push prompt_len      ; второй аргумент - длина
    push prompt          ; первый аргумент - строка
    call print_string
    add rsp, 16         ; очищаем стек (2 аргумента по 8 байт)
```

**Работа со стеком:**
- Стек растет в сторону младших адресов (вниз)
- `push` уменьшает rsp на 8 и помещает значение по адресу [rsp]
- Порядок аргументов обратный (последний аргумент первым)
- `add rsp, 16` - очистка стека (удаление 2 аргументов по 8 байт)

```assembly
    ; Чтение ввода пользователя
    push buffer          ; аргумент - адрес буфера
    call read_input
    add rsp, 8          ; очищаем стек
    
    ; Проверяем, что что-то было введено
    cmp rax, 0
    jle .game_loop
```

**Условные переходы:**
- `cmp rax, 0` - сравнение количества прочитанных байтов с 0
- `jle` - jump if less or equal (переход если меньше или равно)
- Если ввода нет, возвращаемся к началу цикла

```assembly
    ; Преобразуем введенную строку в число 
    mov rdi, buffer      ; адрес буфера с введенными данными
    call string_to_int   ; преобразовать строку в число
    
    ; Проверяем на ошибку преобразования
    cmp rax, -1         ; сравнить результат с -1 (ошибка)
    jne .check_number
```

**Обработка ошибок:**
- После string_to_int в rax будет число или -1 при ошибке
- `jne` - jump if not equal (переход если не равно)

```assembly
.check_number:
    ; Сравниваем с загаданным числом
    cmp rax, secret_number
    jg .too_big
    jl .too_small
    
    ; Если равно - пользователь угадал
    push len_equal
    push msg_equal
    call print_string
    add rsp, 16
    jmp .exit
```

**Сравнения и переходы:**
- `jg` - jump if greater (переход если больше)
- `jl` - jump if less (переход если меньше)
- `jmp` - безусловный переход

```assembly
.exit:
    ; Завершаем программу
    mov rax, 60         ; sys_exit
    xor rdi, rdi        ; код возврата 0
    syscall
```

**Завершение программы:**
- `rax = 60` - номер системного вызова exit
- `xor rdi, rdi` - обнуление rdi (код возврата 0)
- `syscall` - передача управления ядру ОС

## Ключевые концепции ассемблера

### 1. **Метки и адреса**
- Метки (например, `_start:`, `.game_loop:`) представляют собой адреса в памяти
- Локальные метки начинаются с точки (`.метка`)

### 2. **Директивы ассемблера**
- `db` - define byte (определить байт/байты)
- `equ` - define constant (определить константу)
- `times` - повторить операцию заданное количество раз

### 3. **Системные вызовы (syscall)**
- Интерфейс между пользовательской программой и ядром ОС
- Номера вызовов: write=1, read=0, exit=60
- Аргументы передаются через регистры

### 4. **Управление памятью**
- `.data` - инициализированные данные
- `.text` - код программы
- Стек используется для передачи аргументов и хранения локальных переменных

### 5. **Условные и безусловные переходы**
- Основа управления потоком выполнения
- `jmp` - безусловный переход
- `je/jne` - переход по равенству/неравенству
- `jg/jl` - переход по знаковому сравнению
- `ja/jb` - переход по беззнаковому сравнению

## Работа программы по шагам

1. **Начало выполнения** - программа начинает с метки `_start`
2. **Вывод приглашения** - вызов print_string для prompt
3. **Чтение ввода** - вызов read_input в buffer
4. **Проверка ввода** - если пустой ввод, возврат к шагу 2
5. **Преобразование строки** - string_to_int преобразует ASCII в число
6. **Проверка на ошибку** - если не число, вывод сообщения об ошибке
7. **Сравнение с secret_number** - определение больше/меньше/равно
8. **Вывод результата** - соответствующее сообщение
9. **Повтор или завершение** - если угадал -> выход, иначе -> шаг 2

Эта программа демонстрирует основные концепции низкоуровневого программирования: работу с памятью, системные вызовы, управление потоком выполнения и обработку ошибок.