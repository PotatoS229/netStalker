Сдесь я хотел бы рассказать о Физических атаках и как ими воспользоваться при помощи Bash и минимальных навыках в пайке и тому прочему.

Представте ситуацию, что ваша жертва или цель заблокировал свой ЭВМ и ушел и у вас есть всего 20 минут, что бы открыть и взломать пк и получить доступ к данным, что же делать 
1) Забрать ноутбук, но в таком случае вас расскроют, не забывайте, что нас окружают камеры.
2) Взломать ноутбук и до возвращения цели скрыться, если цель не заметит изменений, то вы в безопасности.

Первый способ мне не очень нравится, так как он слишком рискованный, а наша цель взломать и остаться на свободе, так что выбираем путь номер 2.

Как же реализовать даннуя атаку, все очень просто, но перед реализацией надо рассмотреть пару нюансов и изучить в течении 5 минут техническую базу и то как мы это будем делать.

ТЕОРИЯ:
Для реализации атаки физического уровня иногда даже не надо иметь прямой доступ к компьютеру, достаточно просто грамотно определить каким способом в офисе или в любом дургом месте происходит интернет соединение, за частую в моем опыте и в жизни я встречаюсь с такой технологией как RJ45-это стандартный модуль разьем для LAN и WAN, и чем же он нам пригодится, мой ответ, он нам и не дужен нам нужен доступ к интернет проводу(Ethernet), У данного провода существует на данный момент 8 стандартов, Мы разберем самые распространненые.

Провод RJ-45 (8Р8С) состоит из четырех пар цветных жил. Каждая пара -
это два провода, скрученных между собой. У данного провода есть 8 проводов 
1. ТХ+
2. ТХ-
3. RX+
4. (DC+) - РоЕ
5. (DC+) - РоЕ
6. RX-
7. (DC-) - РоЕ
8. (DC-) - РоЕ

У каждой из пар есть своя роль 
1. Передача данных - (TX+/-)
2. Прием данных - (RX+/-)
3. РоЕ «-», данные 1000 Мбит/с - ( (DC-) - РоЕ )
4. РоЕ <<+>>, данные 1000 Мбит/с - ( (DC+) - РоЕ )

Современные стандарты Ethernet:

    100BASE-TX (IEEE 802.3u) — Fast Ethernet (100 Мбит/с) по витой паре CAT5

    1000BASE-T (IEEE 802.3ab) — Gigabit Ethernet (1 Гбит/с) по CAT5e/CAT6

    2.5GBASE-T/5GBASE-T (IEEE 802.3bz) — Multi-Gigabit Ethernet по существующей инфраструктуре

    10GBASE-T (IEEE 802.3an) — 10 Gigabit Ethernet по CAT6a/CAT7





В целом с расмотром типов проводов и их стандартами мы закончили, предлагаю переходить к более сладкой теме.

Как же совершить кражу данных имея только доступ к проводу.

Инструменты:
    1. провод Ethernet
    2. два крокодила

Наши действия
    1. Берем нащ провод ethernet, и редим его так чтобы с одной стороны был RJ45, а с 
    другой стороны был доступ к проводам.

    2. Находим Rx+/- или TX+/- и крепим к ним крокодилы.

    3. Данный провод напрямую подключаем к сетевой карте атакуещего устройства, в качестве атакуещего устройства может подойти любой микрокомпьютер с имеющимся на борту 
    кабелем Ethernet.

    4. Надрезаем провод Ethernet нашей цели так что бы провод и жилы не пострадали и могли передавать данный и дальше

    5. Берем наш модифицированный кабель и подключаем его к RX паре или TX паре в завиимости от того к каким проводам подключены наши крокодилы, если они подключены к RX паре, то на атакуемом проводе подключаемся также к Rx, тоже правило действует и для TX. Срезать оплетку с RX и TX не обчзательно, достаточно просто надовить крокодилами на провода и изоляция слезет и крокодилы получат доступ к медному проводу.

    6. Воспользуемся скриптом для получения доступа к данным.

    Но перед этим я бы хотел бы дать вам базу по языку C++ на котором мы напишим скрипт, послде чего уже перепишем его на bash 
    Для выполнения данной задачи нам понадобится понимание и знание базы по C++, а все остальное я вам попытаюсь базово объяснить, с каждым проектом у вас будут появлять все больше и больше знаний, не переживайте если вы все не поймете сразу, так и должно быть, но со временем у вас будут развиваться все больше и больше навыков и появится понимание.

    Начнем наше знакомство с базы, как же сделать TCP сервер, 
    TCP - транспортный протокол, который гаранитирует, то что сообщение убдет отправленно и принято буз патерь.

    ```cpp
    //Начнем мы с того что добавим в проект нужные нам библиотеки 
    #include <sys/socket.h> // Это библиотека, дает нам основные функции и сртуктуры для работы с сокетами 
    #include <sys/types.h> // Эта библиотека предназначена для определения типов данных
    #include <netinet/in.h> // эта библиотека нужна для работы с интернет аддрессами (IPv4, IPv6)
    
    #include <stdlib.h> // Добавляет стандартные функции общего назначения
    #include <string.h> // Нужня для работы с строками и памятью
    #include <stdio.h> // Стандартный ввод и вывод
    #include <unistd.h> // Нужна для доступа к POSIX совместимым системам.

    //Сдесь я опишу самое главное о <sys/socket.h> и <netinet/in.h>

    //<sys/socket.h>
    //  int server_socket = socket(int domain, int type, int protocol); - создание сокета
    //  bind(server_socket, ...) - привязка сокета к аддрессу
    //  listen(server_socket, ...) - прослушивание входящих соединений
    //  accept(server_socket, ...) - принятие соединения 
    //  connect(server_socket, ...) - подключение к серверу 
    //!! Сдесь будут описанный основные домены, типы и протаколы из <sys/socket.h>
    //    Домены(основные):
    //      AF_INET - IPv4 интернет-адреса
    //      AF_UNIX - Локальные сокеты(файловая система)
    //      AF_INET6 - IPv6 интернет-адреса
    //      AF_PACKET - Низкоуровневые пакеты(сырые сокеты)
    //      AF_NETLINK - Взаимодействие с ядром Linux
    //      AF_IPX 
    //    Домены(дополнительные):
    //      AF_IPX - Протакол IPX/SPX (Novell)
    //      AF_APPLETALK - протакол AppleTalk
    //      AF_BLUETOOTH - BlueTooth сокеты
    //      AF_CAN - Controller Area Network
    //      AF_X25 - X.25 протакол
    //      AF_AX25 - Amateur Radio X.25
    //    Типы сокетов(основные):
    //      SOCK_STREAM - потоковый сокет(TCP)
    //      SOCK_DGRAM - датаграмный сокет(UDP)
    //      SOCK_RAW - сырой сокет(прямой доступ к IP)
    //      SOCK_SEQPACKET - последовательный пакетный сокет
    //    Протаколы:
    //      IPPROTO_TCP - протакол TCP
    //      IPPROTO_UDP - протакол UDP
    //      IPPROTO_IP - IP протакол 
    //      IPPROTO_ICMP - ICMP протакол(ping)
    //      IPPROTO_RAW - Сырой протакол
    //   
    //                  Таблица совместимости
    // Приложение	         Домен	       Тип	         Протокол
    // Веб-сервер	        AF_INET	    SOCK_STREAM	    IPPROTO_TCP
    // DNS клиент	        AF_INET	    SOCK_DGRAM	    IPPROTO_UDP
    // Ping утилита	        AF_INET	    SOCK_RAW	    IPPROTO_ICMP
    // Межпроцессное	    AF_UNIX	    SOCK_STREAM	    0
    // IPv6 приложение	    AF_INET6	SOCK_STREAM	    IPPROTO_TCP
    // Сетевой анализатор	AF_PACKET	SOCK_RAW	    ETH_P_ALL 
    //
    //!!!Сдесь я бы хотел бы добавить очень важной инфы, если вы такие же как и я, то вас наверное мучает, 
    // что же такое домен, тип и протакол
    //  1) Сокет - отвечает в каком пространстве работать
    //  2) Тип - отвечает как работать сокету 
    //  3) Протакол - По каким правилам работать сокету
    //
    //
    //<netinet/in.h>
    //  struct sockaddr_in{
    //      sa_family_t    sin_family; - семейство адрессов (AF_INET) - IPv4    
    //      in_port_t      sin_sort; - Номер порта(в сетевом порядке байт)
    //      struct in_addr sin_addr; - IP-адрес
    //  }
    //  struct in_addr {
    //      int_addr_t s_addr; - 32 битыный IPv4-адрес
    //  }int fd

   


                        //TCP - server
    //Начнем мы с того что добавим в проект нужные нам библиотеки 
    #include <sys/socket.h> // Это библиотека, дает нам основные функции и сртуктуры для работы с сокетами 
    #include <sys/types.h> // Эта библиотека предназначена для определения типов данных
    #include <netinet/in.h> // эта библиотека нужна для работы с интернет аддрессами (IPv4, IPv6)
    
    #include <stdlib.h> // Добавляет стандартные функции общего назначения
    #include <string.h> // Нужня для работы с строками и памятью
    #include <stdio.h> // Стандартный ввод и вывод
    #include <unistd.h> // Нужна для доступа к POSIX совместимым системам.
    // Вход в программу 
    int main(){
        //Созадаем новый сокет TCP
        int server_socket;
        server_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

        //Указываем адрес сервера 
        struct sockaddr_in server_address;
        server_address.sin_family = AF_INET;
        server_address.sin_port = htos(9002);
        server_address.sin_addr.s_addr = INADDR_ANY;

        //Привязываем сокет к адресу
        bind(server_socket, (struct sockaddr*) &server_address, sezeof(server_address));

        //Прослушивание входящих соединений, то есть сколько соединений может быть одновременно
        listen(server_socket, 5);

        //Создаем клиента и заставляем его принимать сообщение от сервера
        int client_socket;
        client_socket = accept(server_socket, NULL, NULL);

        //Отправляем сообщение 
        char server_message[256] = "You have reached the server!";
        send(client_socket, server_message, sizeof(server_message), 0);

        //Закрываем сокет
        close(server_socket);

        //Возвращаем 0
        return 0;
    }   
    ```


