# Лекция по сетевому программированию на C++

## Часть 1: Теоретические основы

### 1.1 Основные понятия

**Сетевое программирование** - создание программ, которые обмениваются данными по компьютерным сетям.

**Основные модели взаимодействия:**
- **Клиент-серверная модель** - сервер предоставляет услуги, клиенты их потребляют
- **P2P (peer-to-peer)** - равноправные узлы обмениваются данными напрямую

**Ключевые протоколы:**
- **TCP (Transmission Control Protocol)** - надежный, с установкой соединения
- **UDP (User Datagram Protocol)** - ненадежный, без установки соединения

### 1.2 Модель OSI и TCP/IP

```
Модель OSI              Модель TCP/IP
7. Прикладной           | 4. Прикладной
6. Представления        |   (HTTP, FTP, SMTP)
5. Сеансовый            |
________________________|
4. Транспортный         | 3. Транспортный
                        |   (TCP, UDP)
________________________|
3. Сетевой              | 2. Интернет
                        |   (IP, ICMP)
________________________|
2. Канальный            | 1. Сетевой интерфейс
1. Физический           |   (Ethernet, Wi-Fi)
```

### 1.3 Сокеты (Sockets)

**Сокет** - конечная точка сетевого соединения, сочетание:
- IP-адрес (кто)
- Порт (какое приложение)
- Протокол (как)

## Часть 2: Практика на C++

### 2.1 Базовый TCP-сервер

```cpp
#include <iostream>
#include <string>
#include <cstring>      // для memset, strlen
#include <sys/socket.h> // основные функции сокетов
#include <netinet/in.h> // структуры для интернет-адресов
#include <unistd.h>     // для close()
#include <arpa/inet.h>  // для inet_ntoa

// Константы
const int PORT = 8080;           // Порт для прослушивания
const int BUFFER_SIZE = 1024;    // Размер буфера для данных
const int MAX_CONNECTIONS = 5;   // Максимальная очередь подключений

int main() {
    // 1. Создание сокета
    // AF_INET - IPv4, SOCK_STREAM - TCP, 0 - протокол по умолчанию
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0) {
        std::cerr << "Ошибка создания сокета!" << std::endl;
        return 1;
    }
    std::cout << "Сокет создан успешно." << std::endl;

    // 2. Настройка адреса сервера
    struct sockaddr_in address;
    address.sin_family = AF_INET;          // Семейство адресов IPv4
    address.sin_addr.s_addr = INADDR_ANY;  // Принимать соединения на все интерфейсы
    address.sin_port = htons(PORT);        // Преобразование порта в сетевой порядок байт
    
    // Обнуление оставшейся части структуры
    memset(address.sin_zero, 0, sizeof(address.sin_zero));

    // 3. Привязка сокета к адресу
    if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {
        std::cerr << "Ошибка привязки сокета!" << std::endl;
        close(server_fd);
        return 1;
    }
    std::cout << "Сокет привязан к порту " << PORT << std::endl;

    // 4. Перевод сокета в режим прослушивания
    if (listen(server_fd, MAX_CONNECTIONS) < 0) {
        std::cerr << "Ошибка перевода в режим прослушивания!" << std::endl;
        close(server_fd);
        return 1;
    }
    std::cout << "Сервер слушает порт " << PORT << "..." << std::endl;

    // 5. Основной цикл сервера
    while (true) {
        std::cout << "\nОжидание подключения клиента..." << std::endl;
        
        struct sockaddr_in client_addr;
        socklen_t client_addr_len = sizeof(client_addr);
        
        // 6. Принятие входящего соединения
        int client_socket = accept(server_fd, 
                                   (struct sockaddr*)&client_addr, 
                                   &client_addr_len);
        
        if (client_socket < 0) {
            std::cerr << "Ошибка принятия соединения!" << std::endl;
            continue;
        }
        
        // Вывод информации о клиенте
        char client_ip[INET_ADDRSTRLEN];
        inet_ntop(AF_INET, &client_addr.sin_addr, client_ip, INET_ADDRSTRLEN);
        std::cout << "Клиент подключен: IP=" << client_ip 
                  << ", Порт=" << ntohs(client_addr.sin_port) << std::endl;

        // 7. Обмен данными с клиентом
        char buffer[BUFFER_SIZE] = {0};
        
        // Получение данных от клиента
        int bytes_received = recv(client_socket, buffer, BUFFER_SIZE - 1, 0);
        if (bytes_received > 0) {
            buffer[bytes_received] = '\0'; // Завершающий нуль для строки
            std::cout << "Получено от клиента: " << buffer << std::endl;
            
            // Подготовка ответа
            std::string response = "HTTP/1.1 200 OK\r\n";
            response += "Content-Type: text/html\r\n";
            response += "Content-Length: ";
            response += "<html><body><h1>Привет от сервера!</h1></body></html>";
            std::string html_content = "<html><body><h1>Привет от сервера!</h1></body></html>";
            response += "Content-Length: " + std::to_string(html_content.length()) + "\r\n\r\n";
            response += html_content;
            
            // Отправка ответа
            send(client_socket, response.c_str(), response.length(), 0);
            std::cout << "Ответ отправлен клиенту." << std::endl;
        }

        // 8. Закрытие соединения с клиентом
        close(client_socket);
        std::cout << "Соединение с клиентом закрыто." << std::endl;
    }

    // 9. Закрытие серверного сокета
    close(server_fd);
    return 0;
}
```

### 2.2 Базовый TCP-клиент

```cpp
#include <iostream>
#include <string>
#include <cstring>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

const int PORT = 8080;
const int BUFFER_SIZE = 1024;

int main() {
    // 1. Создание сокета
    int client_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (client_fd < 0) {
        std::cerr << "Ошибка создания сокета клиента!" << std::endl;
        return 1;
    }
    std::cout << "Сокет клиента создан." << std::endl;

    // 2. Настройка адреса сервера
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    
    // Преобразование IP-адреса из текстового вида в бинарный
    if (inet_pton(AF_INET, "127.0.0.1", &server_addr.sin_addr) <= 0) {
        std::cerr << "Неверный адрес или адрес не поддерживается!" << std::endl;
        close(client_fd);
        return 1;
    }

    // 3. Установка соединения с сервером
    if (connect(client_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        std::cerr << "Не удалось подключиться к серверу!" << std::endl;
        close(client_fd);
        return 1;
    }
    std::cout << "Подключено к серверу 127.0.0.1:" << PORT << std::endl;

    // 4. Подготовка и отправка HTTP-запроса
    std::string request = "GET / HTTP/1.1\r\n";
    request += "Host: localhost:8080\r\n";
    request += "Connection: close\r\n";
    request += "\r\n"; // Конец заголовков

    std::cout << "Отправка запроса серверу..." << std::endl;
    send(client_fd, request.c_str(), request.length(), 0);

    // 5. Получение ответа от сервера
    char buffer[BUFFER_SIZE] = {0};
    std::string response;
    
    std::cout << "Ожидание ответа от сервера..." << std::endl;
    
    while (true) {
        int bytes_received = recv(client_fd, buffer, BUFFER_SIZE - 1, 0);
        if (bytes_received <= 0) {
            break; // Соединение закрыто или ошибка
        }
        buffer[bytes_received] = '\0';
        response += buffer;
    }

    // 6. Вывод ответа
    std::cout << "\n=== Ответ от сервера ===" << std::endl;
    std::cout << response << std::endl;
    std::cout << "========================" << std::endl;

    // 7. Закрытие сокета
    close(client_fd);
    std::cout << "Соединение закрыто." << std::endl;

    return 0;
}
```

### 2.3 UDP-сервер (простой эхо-сервер)

```cpp
#include <iostream>
#include <cstring>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

const int UDP_PORT = 9090;
const int BUFFER_SIZE = 1024;

int main() {
    // 1. Создание UDP сокета
    // SOCK_DGRAM - для UDP протокола
    int udp_socket = socket(AF_INET, SOCK_DGRAM, 0);
    if (udp_socket < 0) {
        std::cerr << "Ошибка создания UDP сокета!" << std::endl;
        return 1;
    }
    std::cout << "UDP сокет создан." << std::endl;

    // 2. Настройка адреса сервера
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(UDP_PORT);

    // 3. Привязка сокета
    if (bind(udp_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        std::cerr << "Ошибка привязки UDP сокета!" << std::endl;
        close(udp_socket);
        return 1;
    }
    std::cout << "UDP сервер слушает порт " << UDP_PORT << "..." << std::endl;

    // 4. Основной цикл обработки сообщений
    while (true) {
        char buffer[BUFFER_SIZE];
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);

        std::cout << "\nОжидание UDP сообщения..." << std::endl;
        
        // 5. Получение данных от клиента
        // recvfrom блокируется до получения данных
        int bytes_received = recvfrom(udp_socket, buffer, BUFFER_SIZE - 1, 0,
                                      (struct sockaddr*)&client_addr, &client_len);
        
        if (bytes_received < 0) {
            std::cerr << "Ошибка получения данных!" << std::endl;
            continue;
        }

        buffer[bytes_received] = '\0';
        
        // Получение информации о клиенте
        char client_ip[INET_ADDRSTRLEN];
        inet_ntop(AF_INET, &client_addr.sin_addr, client_ip, INET_ADDRSTRLEN);
        
        std::cout << "Получено от " << client_ip << ":" << ntohs(client_addr.sin_port)
                  << " -> " << buffer << std::endl;

        // 6. Подготовка ответа (эхо)
        std::string echo_message = "Эхо от сервера: ";
        echo_message += buffer;

        // 7. Отправка ответа обратно клиенту
        int bytes_sent = sendto(udp_socket, echo_message.c_str(), echo_message.length(), 0,
                                (struct sockaddr*)&client_addr, client_len);
        
        if (bytes_sent < 0) {
            std::cerr << "Ошибка отправки ответа!" << std::endl;
        } else {
            std::cout << "Ответ отправлен клиенту." << std::endl;
        }
    }

    // 8. Закрытие сокета (недостижимый код в данном примере)
    close(udp_socket);
    return 0;
}
```

## Часть 3: Продвинутые концепции

### 3.1 Мультиплексирование с помощью select()

```cpp
#include <iostream>
#include <vector>
#include <sys/select.h>
#include <unistd.h>

void handleMultipleClients(int server_fd) {
    fd_set read_fds;
    int max_fd = server_fd;
    
    // Вектор клиентских сокетов
    std::vector<int> client_sockets;
    
    while (true) {
        // Инициализация набора файловых дескрипторов
        FD_ZERO(&read_fds);
        FD_SET(server_fd, &read_fds);
        
        // Добавление всех клиентских сокетов в набор
        for (int client_fd : client_sockets) {
            FD_SET(client_fd, &read_fds);
            if (client_fd > max_fd) {
                max_fd = client_fd;
            }
        }
        
        // Ожидание активности на любом из сокетов
        // NULL - без таймаута (ожидание бесконечно)
        int activity = select(max_fd + 1, &read_fds, NULL, NULL, NULL);
        
        if (activity < 0) {
            std::cerr << "Ошибка select()" << std::endl;
            break;
        }
        
        // Проверка активности на серверном сокете (новое подключение)
        if (FD_ISSET(server_fd, &read_fds)) {
            struct sockaddr_in client_addr;
            socklen_t client_len = sizeof(client_addr);
            
            int new_client = accept(server_fd, 
                                   (struct sockaddr*)&client_addr, 
                                   &client_len);
            
            if (new_client >= 0) {
                std::cout << "Новый клиент подключен: fd=" << new_client << std::endl;
                client_sockets.push_back(new_client);
            }
        }
        
        // Проверка активности на клиентских сокетах
        for (size_t i = 0; i < client_sockets.size(); i++) {
            int client_fd = client_sockets[i];
            
            if (FD_ISSET(client_fd, &read_fds)) {
                char buffer[1024];
                int bytes_received = recv(client_fd, buffer, sizeof(buffer) - 1, 0);
                
                if (bytes_received <= 0) {
                    // Соединение закрыто или ошибка
                    std::cout << "Клиент отключен: fd=" << client_fd << std::endl;
                    close(client_fd);
                    client_sockets.erase(client_sockets.begin() + i);
                    i--;
                } else {
                    // Обработка полученных данных
                    buffer[bytes_received] = '\0';
                    std::cout << "Получено от клиента " << client_fd 
                              << ": " << buffer << std::endl;
                    
                    // Эхо-ответ
                    send(client_fd, buffer, bytes_received, 0);
                }
            }
        }
    }
    
    // Закрытие всех клиентских сокетов
    for (int client_fd : client_sockets) {
        close(client_fd);
    }
}
```

### 3.2 Класс для работы с сокетами (обертка C++)

```cpp
#include <iostream>
#include <string>
#include <stdexcept>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <arpa/inet.h>

class Socket {
private:
    int sock_fd;
    bool is_closed;
    
public:
    // Конструктор
    Socket(int domain = AF_INET, int type = SOCK_STREAM, int protocol = 0) 
        : is_closed(true) {
        sock_fd = socket(domain, type, protocol);
        if (sock_fd < 0) {
            throw std::runtime_error("Не удалось создать сокет");
        }
        is_closed = false;
    }
    
    // Конструктор из существующего файлового дескриптора
    Socket(int existing_fd) : sock_fd(existing_fd), is_closed(false) {}
    
    // Деструктор
    ~Socket() {
        if (!is_closed) {
            close();
        }
    }
    
    // Запрет копирования
    Socket(const Socket&) = delete;
    Socket& operator=(const Socket&) = delete;
    
    // Перемещение разрешено
    Socket(Socket&& other) noexcept 
        : sock_fd(other.sock_fd), is_closed(other.is_closed) {
        other.sock_fd = -1;
        other.is_closed = true;
    }
    
    // Привязка к адресу
    void bind(const std::string& ip, int port) {
        struct sockaddr_in address;
        address.sin_family = AF_INET;
        address.sin_port = htons(port);
        
        if (inet_pton(AF_INET, ip.c_str(), &address.sin_addr) <= 0) {
            throw std::runtime_error("Неверный IP адрес");
        }
        
        if (::bind(sock_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {
            throw std::runtime_error("Не удалось привязать сокет");
        }
    }
    
    // Прослушивание входящих соединений
    void listen(int backlog = 5) {
        if (::listen(sock_fd, backlog) < 0) {
            throw std::runtime_error("Не удалось перевести в режим прослушивания");
        }
    }
    
    // Принятие входящего соединения
    Socket accept() {
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);
        
        int client_fd = ::accept(sock_fd, 
                                (struct sockaddr*)&client_addr, 
                                &client_len);
        
        if (client_fd < 0) {
            throw std::runtime_error("Ошибка принятия соединения");
        }
        
        return Socket(client_fd);
    }
    
    // Подключение к серверу
    void connect(const std::string& ip, int port) {
        struct sockaddr_in server_addr;
        server_addr.sin_family = AF_INET;
        server_addr.sin_port = htons(port);
        
        if (inet_pton(AF_INET, ip.c_str(), &server_addr.sin_addr) <= 0) {
            throw std::runtime_error("Неверный IP адрес сервера");
        }
        
        if (::connect(sock_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
            throw std::runtime_error("Не удалось подключиться к серверу");
        }
    }
    
    // Отправка данных
    ssize_t send(const void* buffer, size_t length, int flags = 0) {
        return ::send(sock_fd, buffer, length, flags);
    }
    
    // Отправка строки
    ssize_t send(const std::string& message, int flags = 0) {
        return send(message.c_str(), message.length(), flags);
    }
    
    // Получение данных
    ssize_t recv(void* buffer, size_t length, int flags = 0) {
        return ::recv(sock_fd, buffer, length, flags);
    }
    
    // Получение строки
    std::string recvString(size_t max_length = 4096, int flags = 0) {
        char* buffer = new char[max_length + 1];
        ssize_t bytes_received = recv(buffer, max_length, flags);
        
        if (bytes_received <= 0) {
            delete[] buffer;
            return "";
        }
        
        buffer[bytes_received] = '\0';
        std::string result(buffer);
        delete[] buffer;
        return result;
    }
    
    // Закрытие сокета
    void close() {
        if (!is_closed) {
            ::close(sock_fd);
            is_closed = true;
        }
    }
    
    // Получение файлового дескриптора
    int getFd() const { return sock_fd; }
    
    // Проверка закрыт ли сокет
    bool isClosed() const { return is_closed; }
};

// Пример использования класса
void exampleUsage() {
    try {
        // Серверная часть
        Socket server_socket;
        server_socket.bind("127.0.0.1", 8080);
        server_socket.listen();
        
        std::cout << "Сервер запущен..." << std::endl;
        
        Socket client = server_socket.accept();
        std::string message = client.recvString();
        std::cout << "Получено: " << message << std::endl;
        
        client.send("Ответ от сервера");
        
        // Клиентская часть
        Socket client_socket;
        client_socket.connect("127.0.0.1", 8080);
        client_socket.send("Привет, сервер!");
        
        std::string response = client_socket.recvString();
        std::cout << "Ответ сервера: " << response << std::endl;
        
    } catch (const std::exception& e) {
        std::cerr << "Ошибка: " << e.what() << std::endl;
    }
}
```

## Часть 4: Лучшие практики и рекомендации

### 4.1 Обработка ошибок

Всегда проверяйте возвращаемые значения системных вызовов:

```cpp
int result = some_system_call();
if (result < 0) {
    // Используйте perror или strerror для получения описания ошибки
    perror("Ошибка в some_system_call");
    // или
    std::cerr << "Ошибка: " << strerror(errno) << std::endl;
}
```

### 4.2 Безопасная работа с сокетами

1. **Валидация данных**: Всегда проверяйте входящие данные
2. **Буферы**: Используйте буферы фиксированного размера и проверяйте границы
3. **Таймауты**: Устанавливайте таймауты на операции
4. **Resource Leak**: Всегда закрывайте сокеты в finally-блоке или деструкторе

### 4.3 Производительность

1. Используйте неблокирующие сокеты для высоконагруженных серверов
2. Рассмотрите использование epoll (Linux) или kqueue (BSD) вместо select()
3. Используйте пулы потоков для обработки множества соединений

## Заключение

Сетевое программирование на C++ требует понимания как низкоуровневых системных вызовов, так и сетевых протоколов. Начните с простых примеров, постепенно переходя к более сложным архитектурам. Современные фреймворки (Boost.Asio, POCO) могут упростить разработку, но понимание основ обязательно.

**Дополнительные темы для изучения:**
1. HTTP/HTTPS протоколы
2. WebSocket для двусторонней связи
3. Мультипоточные серверы
4. Асинхронное программирование
5. Безопасность сетевых приложений