Полное руководство по сетевому программированию на C++

Часть 1: Основы сетевого программирования

Введение

Сетевое программирование позволяет приложениям обмениваться данными через компьютерные сети. Основная концепция строится вокруг сокетов - конечных точек для обмена данными между программами, работающими в сети.

Основные понятия

1. TCP (Transmission Control Protocol) - надежный протокол с установкой соединения
2. UDP (User Datagram Protocol) - быстрый протокол без установки соединения
3. IP-адрес - уникальный адрес устройства в сети
4. Порт - числовой идентификатор конкретного приложения на устройстве (0-65535)
5. Клиент-серверная модель - основная архитектура сетевых приложений

Часть 2: Библиотеки и настройка

Основные библиотеки для работы с сетью в C++

```cpp
// Для Linux/macOS
#include <sys/socket.h>    // Основные функции сокетов
#include <netinet/in.h>    // Структуры для интернет-адресов
#include <arpa/inet.h>     // Функции преобразования адресов
#include <unistd.h>        // close()
#include <cstring>         // memset(), strerror()

// Для Windows (Winsock)
#include <winsock2.h>
#include <ws2tcpip.h>
#pragma comment(lib, "ws2_32.lib") // Автоматическая линковка библиотеки

// Общие для всех платформ
#include <iostream>
#include <string>
#include <cstdlib>
```

Инициализация сети (особенно для Windows)

```cpp
#ifdef _WIN32
// Для Windows необходимо инициализировать Winsock
WSADATA wsaData;
int result = WSAStartup(MAKEWORD(2, 2), &wsaData);
if (result != 0) {
    std::cerr << "WSAStartup failed: " << result << std::endl;
    return 1;
}
#endif
```

Часть 3: TCP-программирование

TCP-сервер (пошаговое создание)

```cpp
#include <iostream>
#include <cstring>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int main() {
    // Шаг 1: Создание сокета
    // socket(домен, тип, протокол)
    // AF_INET - IPv4, SOCK_STREAM - TCP, 0 - автоматический выбор протокола
    int serverSocket = socket(AF_INET, SOCK_STREAM, 0);
    if (serverSocket == -1) {
        std::cerr << "Ошибка создания сокета: " << strerror(errno) << std::endl;
        return -1;
    }
    std::cout << "Сокет успешно создан!" << std::endl;

    // Шаг 2: Настройка адреса сервера
    struct sockaddr_in serverAddr;
    memset(&serverAddr, 0, sizeof(serverAddr));  // Обнуляем структуру
    
    serverAddr.sin_family = AF_INET;             // Семейство адресов IPv4
    serverAddr.sin_port = htons(8080);           // Порт 8080, htons - преобразование в сетевой порядок байт
    serverAddr.sin_addr.s_addr = INADDR_ANY;     // Принимать соединения на все интерфейсы
    
    // Шаг 3: Привязка сокета к адресу
    if (bind(serverSocket, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == -1) {
        std::cerr << "Ошибка привязки: " << strerror(errno) << std::endl;
        close(serverSocket);
        return -1;
    }
    std::cout << "Сокет привязан к порту 8080" << std::endl;

    // Шаг 4: Начало прослушивания порта
    // listen(дескриптор сокета, размер очереди подключений)
    if (listen(serverSocket, 5) == -1) {
        std::cerr << "Ошибка listen: " << strerror(errno) << std::endl;
        close(serverSocket);
        return -1;
    }
    std::cout << "Сервер слушает порт 8080..." << std::endl;

    // Шаг 5: Принятие подключения
    struct sockaddr_in clientAddr;
    socklen_t clientLen = sizeof(clientAddr);
    
    // accept блокирует выполнение до тех пор, пока не появится новое подключение
    int clientSocket = accept(serverSocket, (struct sockaddr*)&clientAddr, &clientLen);
    if (clientSocket == -1) {
        std::cerr << "Ошибка accept: " << strerror(errno) << std::endl;
        close(serverSocket);
        return -1;
    }
    
    // Вывод информации о клиенте
    char clientIP[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &clientAddr.sin_addr, clientIP, INET_ADDRSTRLEN);
    std::cout << "Подключен клиент: " << clientIP << ":" << ntohs(clientAddr.sin_port) << std::endl;

    // Шаг 6: Обмен данными с клиентом
    char buffer[1024];
    memset(buffer, 0, sizeof(buffer));
    
    // Получение данных от клиента
    int bytesReceived = recv(clientSocket, buffer, sizeof(buffer) - 1, 0);
    if (bytesReceived == -1) {
        std::cerr << "Ошибка приема данных: " << strerror(errno) << std::endl;
    } else {
        buffer[bytesReceived] = '\0'; // Добавляем нуль-терминатор для строки
        std::cout << "Получено от клиента: " << buffer << std::endl;
        
        // Отправка ответа клиенту
        const char* response = "Привет от сервера!";
        send(clientSocket, response, strlen(response), 0);
    }

    // Шаг 7: Закрытие соединений
    close(clientSocket);
    close(serverSocket);
    
    std::cout << "Сервер завершил работу" << std::endl;
    return 0;
}
```

TCP-клиент

```cpp
#include <iostream>
#include <cstring>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int main() {
    // Шаг 1: Создание сокета
    int clientSocket = socket(AF_INET, SOCK_STREAM, 0);
    if (clientSocket == -1) {
        std::cerr << "Ошибка создания сокета: " << strerror(errno) << std::endl;
        return -1;
    }

    // Шаг 2: Настройка адреса сервера
    struct sockaddr_in serverAddr;
    memset(&serverAddr, 0, sizeof(serverAddr));
    
    serverAddr.sin_family = AF_INET;                     // IPv4
    serverAddr.sin_port = htons(8080);                   // Порт сервера
    serverAddr.sin_addr.s_addr = inet_addr("127.0.0.1"); // localhost
    
    // Альтернативный способ установки адреса:
    // inet_pton(AF_INET, "127.0.0.1", &serverAddr.sin_addr);

    // Шаг 3: Подключение к серверу
    if (connect(clientSocket, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == -1) {
        std::cerr << "Ошибка подключения: " << strerror(errno) << std::endl;
        close(clientSocket);
        return -1;
    }
    std::cout << "Подключено к серверу!" << std::endl;

    // Шаг 4: Отправка данных серверу
    const char* message = "Привет от клиента!";
    int bytesSent = send(clientSocket, message, strlen(message), 0);
    if (bytesSent == -1) {
        std::cerr << "Ошибка отправки: " << strerror(errno) << std::endl;
    } else {
        std::cout << "Отправлено " << bytesSent << " байт" << std::endl;
    }

    // Шаг 5: Получение ответа от сервера
    char buffer[1024];
    memset(buffer, 0, sizeof(buffer));
    
    int bytesReceived = recv(clientSocket, buffer, sizeof(buffer) - 1, 0);
    if (bytesReceived == -1) {
        std::cerr << "Ошибка приема: " << strerror(errno) << std::endl;
    } else if (bytesReceived == 0) {
        std::cout << "Сервер закрыл соединение" << std::endl;
    } else {
        buffer[bytesReceived] = '\0';
        std::cout << "Получено от сервера: " << buffer << std::endl;
    }

    // Шаг 6: Закрытие соединения
    close(clientSocket);
    std::cout << "Клиент завершил работу" << std::endl;
    
    return 0;
}
```

Часть 4: UDP-программирование

UDP-сервер

```cpp
#include <iostream>
#include <cstring>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int main() {
    // Шаг 1: Создание UDP сокета
    // SOCK_DGRAM - указывает на использование UDP
    int serverSocket = socket(AF_INET, SOCK_DGRAM, 0);
    if (serverSocket == -1) {
        std::cerr << "Ошибка создания сокета: " << strerror(errno) << std::endl;
        return -1;
    }

    // Шаг 2: Настройка адреса сервера
    struct sockaddr_in serverAddr;
    memset(&serverAddr, 0, sizeof(serverAddr));
    
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(9090);     // Порт 9090 для UDP
    serverAddr.sin_addr.s_addr = INADDR_ANY;

    // Шаг 3: Привязка сокета
    if (bind(serverSocket, (struct sockaddr*)&serverAddr, sizeof(serverAddr)) == -1) {
        std::cerr << "Ошибка привязки: " << strerror(errno) << std::endl;
        close(serverSocket);
        return -1;
    }
    
    std::cout << "UDP сервер слушает порт 9090..." << std::endl;

    // Шаг 4: Прием данных
    char buffer[1024];
    struct sockaddr_in clientAddr;
    socklen_t clientLen = sizeof(clientAddr);
    
    while (true) {
        memset(buffer, 0, sizeof(buffer));
        
        // recvfrom блокирует выполнение до получения данных
        int bytesReceived = recvfrom(serverSocket, buffer, sizeof(buffer) - 1, 0,
                                    (struct sockaddr*)&clientAddr, &clientLen);
        
        if (bytesReceived == -1) {
            std::cerr << "Ошибка приема: " << strerror(errno) << std::endl;
            continue;
        }
        
        buffer[bytesReceived] = '\0';
        
        // Получение информации о клиенте
        char clientIP[INET_ADDRSTRLEN];
        inet_ntop(AF_INET, &clientAddr.sin_addr, clientIP, INET_ADDRSTRLEN);
        
        std::cout << "Получено от " << clientIP << ":" 
                  << ntohs(clientAddr.sin_port) << ": " << buffer << std::endl;
        
        // Шаг 5: Отправка ответа
        const char* response = "UDP ответ от сервера!";
        sendto(serverSocket, response, strlen(response), 0,
               (struct sockaddr*)&clientAddr, clientLen);
        
        // Для выхода из цикла (в реальном приложении нужен более сложный механизм)
        if (strcmp(buffer, "exit") == 0) {
            break;
        }
    }

    // Шаг 6: Закрытие сокета
    close(serverSocket);
    return 0;
}
```

UDP-клиент

```cpp
#include <iostream>
#include <cstring>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

int main() {
    // Шаг 1: Создание UDP сокета
    int clientSocket = socket(AF_INET, SOCK_DGRAM, 0);
    if (clientSocket == -1) {
        std::cerr << "Ошибка создания сокета: " << strerror(errno) << std::endl;
        return -1;
    }

    // Шаг 2: Настройка адреса сервера
    struct sockaddr_in serverAddr;
    memset(&serverAddr, 0, sizeof(serverAddr));
    
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(9090);                 // Порт UDP сервера
    serverAddr.sin_addr.s_addr = inet_addr("127.0.0.1"); // Адрес сервера

    // Шаг 3: Отправка данных
    const char* message = "Привет от UDP клиента!";
    int bytesSent = sendto(clientSocket, message, strlen(message), 0,
                          (struct sockaddr*)&serverAddr, sizeof(serverAddr));
    
    if (bytesSent == -1) {
        std::cerr << "Ошибка отправки: " << strerror(errno) << std::endl;
        close(clientSocket);
        return -1;
    }
    
    std::cout << "Отправлено " << bytesSent << " байт" << std::endl;

    // Шаг 4: Получение ответа
    char buffer[1024];
    memset(buffer, 0, sizeof(buffer));
    
    struct sockaddr_in fromAddr;
    socklen_t fromLen = sizeof(fromAddr);
    
    int bytesReceived = recvfrom(clientSocket, buffer, sizeof(buffer) - 1, 0,
                                (struct sockaddr*)&fromAddr, &fromLen);
    
    if (bytesReceived == -1) {
        std::cerr << "Ошибка приема: " << strerror(errno) << std::endl;
    } else {
        buffer[bytesReceived] = '\0';
        std::cout << "Получен ответ: " << buffer << std::endl;
    }

    // Шаг 5: Закрытие сокета
    close(clientSocket);
    return 0;
}
```

Часть 5: Важные функции и структуры

Основные функции

1. socket() - создание нового сокета
2. bind() - привязка сокета к адресу и порту
3. listen() (TCP) - начало прослушивания входящих подключений
4. accept() (TCP) - принятие входящего подключения
5. connect() (TCP) - подключение к удаленному сокету
6. send()/recv() (TCP) - отправка/прием данных
7. sendto()/recvfrom() (UDP) - отправка/прием данных (с указанием адреса)
8. close() (Linux) / closesocket() (Windows) - закрытие сокета

Основные структуры

```cpp
// Структура для хранения IPv4 адреса
struct sockaddr_in {
    short sin_family;           // AF_INET (IPv4)
    unsigned short sin_port;    // Номер порта (в сетевом порядке байт)
    struct in_addr sin_addr;    // IP адрес
    char sin_zero[8];           // Дополнение до размера sockaddr
};

// Структура для хранения IP адреса
struct in_addr {
    unsigned long s_addr;       // Адрес в сетевом порядке байт
};
```

Функции преобразования

1. htons() - host to network short (16-битное число)
2. htonl() - host to network long (32-битное число)
3. ntohs() - network to host short
4. ntohl() - network to host long
5. inet_addr() - преобразование строки в IP-адрес (устаревшая)
6. inet_pton() - преобразование строки в IP-адрес (рекомендуемая)
7. inet_ntop() - преобразование IP-адреса в строку

Часть 6: Практические примеры и лучшие практики

Многопоточный TCP-сервер

```cpp
#include <iostream>
#include <cstring>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <thread>
#include <vector>

// Функция для обработки клиента в отдельном потоке
void handleClient(int clientSocket, sockaddr_in clientAddr) {
    char clientIP[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &clientAddr.sin_addr, clientIP, INET_ADDRSTRLEN);
    
    std::cout << "Обработка клиента: " << clientIP << std::endl;
    
    char buffer[1024];
    while (true) {
        memset(buffer, 0, sizeof(buffer));
        int bytesReceived = recv(clientSocket, buffer, sizeof(buffer) - 1, 0);
        
        if (bytesReceived <= 0) {
            std::cout << "Клиент отключился: " << clientIP << std::endl;
            break;
        }
        
        buffer[bytesReceived] = '\0';
        std::cout << "От " << clientIP << ": " << buffer << std::endl;
        
        // Эхо-ответ
        send(clientSocket, buffer, bytesReceived, 0);
    }
    
    close(clientSocket);
}

int main() {
    int serverSocket = socket(AF_INET, SOCK_STREAM, 0);
    if (serverSocket == -1) {
        std::cerr << "Ошибка создания сокета" << std::endl;
        return -1;
    }

    // Установка опции для повторного использования адреса
    int opt = 1;
    setsockopt(serverSocket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in serverAddr;
    memset(&serverAddr, 0, sizeof(serverAddr));
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(8080);
    serverAddr.sin_addr.s_addr = INADDR_ANY;

    if (bind(serverSocket, (sockaddr*)&serverAddr, sizeof(serverAddr)) == -1) {
        std::cerr << "Ошибка привязки" << std::endl;
        close(serverSocket);
        return -1;
    }

    if (listen(serverSocket, 10) == -1) {
        std::cerr << "Ошибка listen" << std::endl;
        close(serverSocket);
        return -1;
    }

    std::cout << "Многопоточный сервер запущен на порту 8080" << std::endl;
    
    std::vector<std::thread> threads;
    
    while (true) {
        sockaddr_in clientAddr;
        socklen_t clientLen = sizeof(clientAddr);
        
        int clientSocket = accept(serverSocket, (sockaddr*)&clientAddr, &clientLen);
        if (clientSocket == -1) {
            std::cerr << "Ошибка accept" << std::endl;
            continue;
        }
        
        // Создаем новый поток для обработки клиента
        threads.emplace_back(handleClient, clientSocket, clientAddr);
    }

    // Ожидаем завершения всех потоков
    for (auto& thread : threads) {
        if (thread.joinable()) {
            thread.join();
        }
    }

    close(serverSocket);
    return 0;
}
```

Часть 7: Обработка ошибок и отладка

Общие ошибки и их решение

1. "Address already in use" - порт занят
   ```cpp
   // Решение: установить опцию SO_REUSEADDR
   int opt = 1;
   setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
   ```
2. "Connection refused" - сервер не запущен или не слушает порт
3. "Broken pipe" - попытка записи в закрытое соединение

Функция для вывода ошибок

```cpp
void printError(const std::string& message) {
    std::cerr << message << ": " << strerror(errno) << std::endl;
}

// Использование
if (bind(sock, ...) == -1) {
    printError("Ошибка привязки");
    return -1;
}
```

Часть 8: Кросс-платформенный код

```cpp
#ifdef _WIN32
    #include <winsock2.h>
    #include <ws2tcpip.h>
    #pragma comment(lib, "ws2_32.lib")
    #define close closesocket
    #define socklen_t int
#else
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>
    #include <unistd.h>
#endif

#include <iostream>
#include <cstring>

class SocketWrapper {
private:
#ifdef _WIN32
    WSADATA wsaData;
#endif
    int sockfd;
    
public:
    SocketWrapper() : sockfd(-1) {
#ifdef _WIN32
        // Инициализация Winsock на Windows
        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
            std::cerr << "Ошибка инициализации Winsock" << std::endl;
        }
#endif
    }
    
    ~SocketWrapper() {
        if (sockfd != -1) {
            close(sockfd);
        }
#ifdef _WIN32
        WSACleanup();
#endif
    }
    
    // Другие методы...
};
```

Часть 9: Домашнее задание

1. Создайте простой чат-сервер, который может обрабатывать несколько клиентов одновременно
2. Реализуйте файловый сервер для передачи файлов
3. Создайте систему мониторинга сети, которая проверяет доступность серверов
4. Реализуйте простой HTTP-сервер, отвечающий на GET-запросы

Заключение

Сетевое программирование в C++ требует понимания основных концепций и аккуратной работы с системными вызовами. Начните с простых примеров, постепенно усложняя их. Практикуйтесь, экспериментируйте и не бойтесь ошибок - они лучший способ обучения!

Дополнительные ресурсы для изучения:

1. Документация по сокетам (man-страницы в Linux)
2. RFC стандарты (RFC 793 для TCP, RFC 768 для UDP)
3. Книга "Unix Network Programming" W. Richard Stevens
4. Онлайн-курсы по сетевому программированию