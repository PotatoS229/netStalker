Начнем с того, зачем C++. Ответ прост, это язык который порадил величайшее покаление программистов, с него начинали многие, и не просто так, если вы хотите максимально подробно понимать от куда ростут ноги у многих языков программирования, то вам стоит освоить C++, и этот курс будит самым большим, среди других, курсов, так как кроме основ мы с вами захватим и многие другие аспекты, и одну из самых любимых моих тем, но и при этом же очень сложную, это сети, для прохождения данного курса, я рекомендую вам установить linux, так как разница не существенная, но иногда у вас на виндоус не будет запускаться программа, которую я буду сдесь показывать.

Чесно говоря я не хочу обучать вас основам, так как я их очень хорошо знаю, и знаю что на их освоение у вас уйдет мало времени, по эттому прошу вас возвращаться аосле того как вы изучите базу, под базой я подрузомеваю, когда вы дойдете до темы указатели, структуры, векторы.

УРА!!! Ты верунулся, ну что тогда пора начинать, и начнем мы сразу со сложного, я уже говорил, что мне нравится сетевое программирование, по этому мы перейдем с низкой планки на которой вы находитесь, до одной из самых высоких, мы перепрыгним не просто через голову, а через 10 голов, а все недостающие концепции мы будим узнавать по делу, надеюсь мы договорились)))

Начнем мы с того, что поймем что такое сеть и какая она бывает
Умные дядьки придумали таблички, существует 2 таблички, и каждая из них достойня того что бы мы на нее посмотрели 
1) Первая табличка называется OSI

И выглядит она примерно так 
Конечно! Вот две таблицы для вашей статьи в формате Markdown — одна по модели OSI, другая по модели DoD (TCP/IP).

---

### **Модель OSI (7 уровней)**

| № уровня | Название уровня (рус.) | Название уровня (англ.) | Протоколы и устройства | Функции и задачи | Пример данных |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **7** | **Прикладной** | Application | HTTP, HTTPS, FTP, SMTP, DNS, Telnet, SSH | Доступ к сетевым службам, взаимодействие с пользователем | Данные приложений (HTTP-запрос, email) |
| **6** | **Представительский** | Presentation | SSL/TLS, JPEG, MPEG, ASCII, JSON, XML | Преобразование данных (шифрование, сжатие, кодирование) | Зашифрованные или сжатые данные |
| **5** | **Сеансовый** | Session | NetBIOS, RPC, PAP, PPTP | Установление, управление и завершение сеанса связи | Сеансовые управляющие сообщения |
| **4** | **Транспортный** | Transport | TCP, UDP, SCTP | Гарантированная/негарантированная доставка данных, управление потоком, сегментация | **Сегменты** (TCP) / **Дейтаграммы** (UDP) |
| **3** | **Сетевой** | Network | IP (IPv4/IPv6), ICMP, OSPF, BGP, Router | Логическая адресация, маршрутизация между сетями | **Пакеты** (IP-пакеты) |
| **2** | **Канальный** | Data Link | Ethernet (MAC), PPP, VLAN, Switch, Bridge, Wi-Fi | Физическая адресация (MAC), обнаружение и исправление ошибок, доступ к среде | **Кадры** (Ethernet-кадры) |
| **1** | **Физический** | Physical | UTP, коаксиальный кабель, оптоволокно, Wi-Fi, Hub, Repeater | Передача битового потока, электрические/оптические сигналы | **Биты** (0 и 1) |

---

### **Модель DoD / TCP/IP (4 уровня)**

Эта модель — основа современного интернета. Её часто сравнивают с OSI, как показано в последнем столбце.

| № уровня | Название уровня | Аналог в OSI | Ключевые протоколы | Функции и задачи | Единица данных |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **4** | **Прикладной** <br>(Application) | Уровни 5-7 (Прикладной, Представления, Сеансовый) | HTTP, HTTPS, FTP, SMTP, DNS, SSH, RTP | Все задачи по представлению данных и коммуникации между приложениями. "Сетевые программы". | Данные приложения (Application Data) |
| **3** | **Транспортный** <br>(Transport) | Уровень 4 (Транспортный) | TCP, UDP | Обеспечение связи "конец-в-конец" (end-to-end), управление потоком, надежность. | Сегменты (TCP) / Дейтаграммы (UDP) |
| **2** | **Межсетевой** <br>(Internet) | Уровень 3 (Сетевой) | IP (IPv4/IPv6), ICMP, ARP, BGP | Логическая адресация (IP-адреса), маршрутизация пакетов по сети из множества путей. | Пакеты (IP-пакеты) |
| **1** | **Сетевого доступа** <br>(Network Access) | Уровни 1-2 (Физический, Канальный) | Ethernet, Wi-Fi, ARP, MAC, DSL | Передача данных по физической среде (кабель, радиоволна), адресация на уровне устройства (MAC). | Кадры (Frames) / Биты (Bits) |

---
## Сокет
Так, так, так
Мы знакомы с OSI и DoD, но это нам дает лишь обстактное понимание как работает сеть
по этому мы изучим самый главынй строительный блок в сетях
Любая сеть должна иметь сокет

Сокет - сокет лучше всего представить как разетку, то есть через него осуществляется взаимодействие клиент-сервер. Это если простыми словами.
А по сути Сокет — это программный интерфейс (API), предоставляющий приложению конечную точку для сетевого взаимодействия, определяемую IP-адресом, номером порта и транспортным протоколом.

---
## Характеристики сокетов 
У всех сокетов при создании задаются характеристики, и только в случае если сокеты имеют одинаковые характеристики, то их можно будет связать друг с другом 
перед тем как мы продолжим хочу показать как выглядит сокет
```cpp
#include <sys/socket.h>
int socket(int domain, int type, inp protacol);
```
И теперь давайте разберем каждый его аспект 
1) int domain - домен, он по сути отвечает на вопрос, в каком пространстве бкдем работать, то есть какой тип связи
    AF_INET / PF_INET - IPv4 интернет-протоколы (наиболее распространенный)

    AF_INET6 / PF_INET6 - IPv6 интернет-протоколы

    AF_UNIX / AF_LOCAL - Локальная коммуникация между процессами на одной машине

    AF_PACKET - Низкоуровневый доступ к сетевым интерфейсам

    AF_NETLINK - Коммуникация между ядром и пользовательским пространством
2) int type - тип, он отвечает на вопрос по каким правилам мы будем рабоать, ну точнее семантику обмена данными, так как у каждого протакола есть свои правила обмена данными
    SOCK_STREAM - Надежный потоковый сокет (TCP)

        Гарантированная доставка, порядок данных

        Двусторонний поток байтов

    SOCK_DGRAM - Датаграммный сокет (UDP)

        Ненадежный, без установления соединения

        Сохраняет границы сообщений

    SOCK_RAW - "Сырой" сокет

        Прямой доступ к сетевым протоколам

        Для разработки протоколов, анализа трафика
3) int protacol - протакол, он отвечает на вопрос какой протакол мы будим использовать 
    0 - Автоматический выбор протокола по умолчанию для типа сокета

        SOCK_STREAM → TCP (IPPROTO_TCP)

        SOCK_DGRAM → UDP (IPPROTO_UDP)

    IPPROTO_TCP - Протокол TCP (обычно с SOCK_STREAM)

    IPPROTO_UDP - Протокол UDP (обычно с SOCK_DGRAM)

    IPPROTO_ICMP - Протокол ICMP (с SOCK_RAW)

---
---
---
## Старт
# Лекция по сетевым примитивам в C++ для начинающих

## Часть 1: Основные концепции сетевого взаимодействия

### Что такое сокет?
Сокет (socket) — это программный интерфейс для сетевого взаимодействия между приложениями. Представьте его как виртуальную "розетку", в которую можно "включить" сетевое соединение.

```cpp
// Простейшая аналогия: сокет - это как телефон
// 1. Создаем телефон (socket)
// 2. Набираем номер (connect)
// 3. Говорим (send)
// 4. Слушаем (recv)
// 5. Кладем трубку (close)
```

### Ключевые понятия

#### 1. IP-адрес
Уникальный идентификатор устройства в сети (например, `192.168.1.1`)

#### 2. Порт
Номер от 0 до 65535, указывающий на конкретное приложение на устройстве:
- 80 - HTTP (веб-серверы)
- 443 - HTTPS
- 22 - SSH
- 53 - DNS

```cpp
// Аналогия с офисным зданием:
// IP-адрес = адрес здания
// Порт = номер офиса в здании
```

#### 3. Протоколы
- **TCP** (Transmission Control Protocol) - надежный, с установкой соединения
- **UDP** (User Datagram Protocol) - быстрый, без установки соединения

## Часть 2: Основные функции работы с сокетами в C++

### 1. Создание сокета: функция `socket()`

```cpp
#include <iostream>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h> // для close()
#include <arpa/inet.h> // для работы с IP-адресами

int main() {
    // Создание TCP-сокета
    int tcp_socket = socket(AF_INET,      // IPv4
                           SOCK_STREAM,   // TCP (потоковый)
                           0);           // Протокол по умолчанию (для TCP это IPPROTO_TCP)
    
    if (tcp_socket < 0) {
        std::cerr << "Ошибка создания TCP-сокета!" << std::endl;
        return -1;
    }
    std::cout << "TCP-сокет создан, дескриптор: " << tcp_socket << std::endl;
    
    // Создание UDP-сокета
    int udp_socket = socket(AF_INET,      // IPv4
                           SOCK_DGRAM,    // UDP (датаграммный)
                           0);           // Протокол по умолчанию (для UDP это IPPROTO_UDP)
    
    if (udp_socket < 0) {
        std::cerr << "Ошибка создания UDP-сокета!" << std::endl;
        close(tcp_socket);
        return -1;
    }
    std::cout << "UDP-сокет создан, дескриптор: " << udp_socket << std::endl;
    
    // Закрытие сокетов
    close(tcp_socket);
    close(udp_socket);
    
    return 0;
}
```

**Параметры функции `socket()`:**

```cpp
// Домен (семейство адресов):
AF_INET      // IPv4 (самый распространенный)
AF_INET6     // IPv6
AF_UNIX      // Локальные сокеты (внутри одной машины)

// Тип сокета:
SOCK_STREAM  // TCP - потоковый, надежный
SOCK_DGRAM   // UDP - датаграммный, быстрый
SOCK_RAW     // RAW - низкоуровневый доступ

// Протокол:
0            // Автоматический выбор (рекомендуется)
IPPROTO_TCP  // Явно указываем TCP
IPPROTO_UDP  // Явно указываем UDP
```

### 2. Привязка сокета к адресу: функция `bind()`

```cpp
#include <iostream>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <cstring> // для memset

int main() {
    // Создаем TCP-сокет
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket < 0) {
        std::cerr << "Ошибка создания сокета!" << std::endl;
        return -1;
    }
    
    // Настраиваем адрес сервера
    struct sockaddr_in server_address;
    memset(&server_address, 0, sizeof(server_address)); // Обнуляем структуру
    
    server_address.sin_family = AF_INET;                // IPv4
    server_address.sin_addr.s_addr = INADDR_ANY;        // Принимаем соединения на все интерфейсы
    server_address.sin_port = htons(8080);             // Порт 8080
    
    // Функция htons() преобразует порт из формата хоста в сетевой
    // (Host TO Network Short) - это важно для кроссплатформенности!
    
    // Привязываем сокет к адресу
    if (bind(server_socket, 
             (struct sockaddr*)&server_address, 
             sizeof(server_address)) < 0) {
        std::cerr << "Ошибка привязки сокета!" << std::endl;
        close(server_socket);
        return -1;
    }
    
    std::cout << "Сокет привязан к адресу 0.0.0.0:8080" << std::endl;
    
    close(server_socket);
    return 0;
}
```

### 3. Прослушивание соединений: функция `listen()`

```cpp
#include <iostream>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <cstring>

int main() {
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket < 0) {
        std::cerr << "Ошибка создания сокета!" << std::endl;
        return -1;
    }
    
    // Настройка адреса
    struct sockaddr_in server_address;
    memset(&server_address, 0, sizeof(server_address));
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_port = htons(8080);
    
    // Привязка
    if (bind(server_socket, (struct sockaddr*)&server_address, 
             sizeof(server_address)) < 0) {
        std::cerr << "Ошибка привязки!" << std::endl;
        close(server_socket);
        return -1;
    }
    
    // Начинаем слушать порт
    // Второй параметр - размер очереди ожидающих соединений
    if (listen(server_socket, 5) < 0) {
        std::cerr << "Ошибка listen!" << std::endl;
        close(server_socket);
        return -1;
    }
    
    std::cout << "Сервер слушает порт 8080..." << std::endl;
    std::cout << "Максимальная очередь соединений: 5" << std::endl;
    
    // Здесь сервер готов принимать соединения
    
    close(server_socket);
    return 0;
}
```

### 4. Принятие соединения: функция `accept()`

```cpp
#include <iostream>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <cstring>

int main() {
    // Создание и настройка серверного сокета
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    
    struct sockaddr_in server_address;
    memset(&server_address, 0, sizeof(server_address));
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_port = htons(8080);
    
    bind(server_socket, (struct sockaddr*)&server_address, sizeof(server_address));
    listen(server_socket, 5);
    
    std::cout << "Ожидание подключения клиента..." << std::endl;
    
    // Структура для хранения адреса клиента
    struct sockaddr_in client_address;
    socklen_t client_address_len = sizeof(client_address);
    
    // accept() блокирует выполнение, пока не придет соединение
    int client_socket = accept(server_socket,
                               (struct sockaddr*)&client_address,
                               &client_address_len);
    
    if (client_socket < 0) {
        std::cerr << "Ошибка accept!" << std::endl;
        close(server_socket);
        return -1;
    }
    
    // Преобразуем IP клиента в читаемый вид
    char client_ip[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &client_address.sin_addr, client_ip, INET_ADDRSTRLEN);
    
    std::cout << "Клиент подключен!" << std::endl;
    std::cout << "IP клиента: " << client_ip << std::endl;
    std::cout << "Порт клиента: " << ntohs(client_address.sin_port) << std::endl;
    std::cout << "Клиентский сокет: " << client_socket << std::endl;
    
    // Закрываем соединения
    close(client_socket);
    close(server_socket);
    
    return 0;
}
```

### 5. Подключение к серверу: функция `connect()`

```cpp
#include <iostream>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <cstring>
#include <arpa/inet.h>

int main() {
    // Создаем клиентский сокет
    int client_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (client_socket < 0) {
        std::cerr << "Ошибка создания сокета!" << std::endl;
        return -1;
    }
    
    // Настраиваем адрес сервера
    struct sockaddr_in server_address;
    memset(&server_address, 0, sizeof(server_address));
    
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(8080); // Порт сервера
    
    // Преобразуем строку с IP в нужный формат
    // "127.0.0.1" - localhost (текущая машина)
    if (inet_pton(AF_INET, "127.0.0.1", &server_address.sin_addr) <= 0) {
        std::cerr << "Неверный адрес сервера!" << std::endl;
        close(client_socket);
        return -1;
    }
    
    // Подключаемся к серверу
    std::cout << "Попытка подключения к 127.0.0.1:8080..." << std::endl;
    
    if (connect(client_socket, 
                (struct sockaddr*)&server_address, 
                sizeof(server_address)) < 0) {
        std::cerr << "Не удалось подключиться к серверу!" << std::endl;
        std::cerr << "Возможно, сервер не запущен" << std::endl;
        close(client_socket);
        return -1;
    }
    
    std::cout << "Успешно подключились к серверу!" << std::endl;
    
    // Теперь можно отправлять и получать данные
    
    close(client_socket);
    return 0;
}
```

### 6. Отправка данных: функция `send()`

```cpp
#include <iostream>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <cstring>
#include <arpa/inet.h>

int main() {
    // Клиент подключается к серверу
    int client_socket = socket(AF_INET, SOCK_STREAM, 0);
    
    struct sockaddr_in server_address;
    memset(&server_address, 0, sizeof(server_address));
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(8080);
    inet_pton(AF_INET, "127.0.0.1", &server_address.sin_addr);
    
    connect(client_socket, (struct sockaddr*)&server_address, sizeof(server_address));
    
    // Подготавливаем сообщение
    const char* message = "Привет, сервер!";
    size_t message_len = strlen(message);
    
    // Отправляем сообщение
    ssize_t bytes_sent = send(client_socket, message, message_len, 0);
    
    if (bytes_sent < 0) {
        std::cerr << "Ошибка отправки данных!" << std::endl;
    } else if (bytes_sent == 0) {
        std::cout << "Соединение закрыто" << std::endl;
    } else {
        std::cout << "Отправлено " << bytes_sent << " байт" << std::endl;
        std::cout << "Сообщение: " << message << std::endl;
    }
    
    // Для UDP используется sendto()
    // sendto(socket, buffer, length, flags, address, address_len)
    
    close(client_socket);
    return 0;
}
```

### 7. Получение данных: функция `recv()`

```cpp
#include <iostream>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <cstring>
#include <arpa/inet.h>

int main() {
    // Серверная часть
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    
    struct sockaddr_in server_address;
    memset(&server_address, 0, sizeof(server_address));
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_port = htons(8080);
    
    bind(server_socket, (struct sockaddr*)&server_address, sizeof(server_address));
    listen(server_socket, 5);
    
    // Принимаем соединение
    struct sockaddr_in client_address;
    socklen_t client_len = sizeof(client_address);
    int client_socket = accept(server_socket, 
                               (struct sockaddr*)&client_address, 
                               &client_len);
    
    // Буфер для приема данных
    char buffer[1024];
    memset(buffer, 0, sizeof(buffer));
    
    // Получаем данные
    std::cout << "Ожидание данных от клиента..." << std::endl;
    
    ssize_t bytes_received = recv(client_socket, buffer, sizeof(buffer) - 1, 0);
    
    if (bytes_received < 0) {
        std::cerr << "Ошибка приема данных!" << std::endl;
    } else if (bytes_received == 0) {
        std::cout << "Клиент отключился" << std::endl;
    } else {
        buffer[bytes_received] = '\0'; // Добавляем завершающий ноль для строки
        std::cout << "Получено " << bytes_received << " байт" << std::endl;
        std::cout << "Сообщение: " << buffer << std::endl;
    }
    
    // Для UDP используется recvfrom()
    // recvfrom(socket, buffer, length, flags, address, address_len)
    
    close(client_socket);
    close(server_socket);
    return 0;
}
```

## Часть 3: Полный пример TCP клиент-сервера

### Сервер (server.cpp)

```cpp
#include <iostream>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <cstring>
#include <arpa/inet.h>

int main() {
    std::cout << "=== TCP СЕРВЕР ===" << std::endl;
    
    // 1. СОЗДАНИЕ СОКЕТА
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket < 0) {
        std::cerr << "ОШИБКА: Не удалось создать сокет!" << std::endl;
        return 1;
    }
    std::cout << "✓ Сокет создан" << std::endl;
    
    // 2. НАСТРОЙКА АДРЕСА СЕРВЕРА
    struct sockaddr_in server_address;
    memset(&server_address, 0, sizeof(server_address));
    
    server_address.sin_family = AF_INET;          // IPv4
    server_address.sin_addr.s_addr = INADDR_ANY;  // Все интерфейсы
    server_address.sin_port = htons(12345);      // Порт 12345
    
    // 3. ПРИВЯЗКА СОКЕТА К АДРЕСУ
    if (bind(server_socket, 
             (struct sockaddr*)&server_address, 
             sizeof(server_address)) < 0) {
        std::cerr << "ОШИБКА: Не удалось привязать сокет!" << std::endl;
        close(server_socket);
        return 1;
    }
    std::cout << "✓ Сокет привязан к порту 12345" << std::endl;
    
    // 4. НАЧИНАЕМ СЛУШАТЬ ПОРТ
    if (listen(server_socket, 3) < 0) {  // Очередь из 3 соединений
        std::cerr << "ОШИБКА: Не удалось начать прослушивание!" << std::endl;
        close(server_socket);
        return 1;
    }
    std::cout << "✓ Сервер слушает порт 12345" << std::endl;
    std::cout << "✓ Ожидание клиентов..." << std::endl;
    
    // 5. ПРИНИМАЕМ СОЕДИНЕНИЕ
    struct sockaddr_in client_address;
    socklen_t client_len = sizeof(client_address);
    
    int client_socket = accept(server_socket,
                               (struct sockaddr*)&client_address,
                               &client_len);
    
    if (client_socket < 0) {
        std::cerr << "ОШИБКА: Не удалось принять соединение!" << std::endl;
        close(server_socket);
        return 1;
    }
    
    // Получаем информацию о клиенте
    char client_ip[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &client_address.sin_addr, client_ip, INET_ADDRSTRLEN);
    
    std::cout << "✓ Клиент подключен!" << std::endl;
    std::cout << "  IP: " << client_ip << std::endl;
    std::cout << "  Порт: " << ntohs(client_address.sin_port) << std::endl;
    
    // 6. ПРИЕМ СООБЩЕНИЯ ОТ КЛИЕНТА
    char buffer[1024];
    memset(buffer, 0, sizeof(buffer));
    
    std::cout << "✓ Ожидание сообщения от клиента..." << std::endl;
    
    ssize_t bytes_received = recv(client_socket, buffer, sizeof(buffer) - 1, 0);
    
    if (bytes_received > 0) {
        buffer[bytes_received] = '\0';
        std::cout << "✓ Получено сообщение: " << buffer << std::endl;
        
        // 7. ОТПРАВКА ОТВЕТА КЛИЕНТУ
        const char* response = "Сообщение получено!";
        send(client_socket, response, strlen(response), 0);
        std::cout << "✓ Ответ отправлен клиенту" << std::endl;
    }
    
    // 8. ЗАКРЫТИЕ СОКЕТОВ
    close(client_socket);
    std::cout << "✓ Клиентский сокет закрыт" << std::endl;
    
    close(server_socket);
    std::cout << "✓ Серверный сокет закрыт" << std::endl;
    
    return 0;
}
```

### Клиент (client.cpp)

```cpp
#include <iostream>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <cstring>
#include <arpa/inet.h>

int main() {
    std::cout << "=== TCP КЛИЕНТ ===" << std::endl;
    
    // 1. СОЗДАНИЕ СОКЕТА
    int client_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (client_socket < 0) {
        std::cerr << "ОШИБКА: Не удалось создать сокет!" << std::endl;
        return 1;
    }
    std::cout << "✓ Сокет создан" << std::endl;
    
    // 2. НАСТРОЙКА АДРЕСА СЕРВЕРА
    struct sockaddr_in server_address;
    memset(&server_address, 0, sizeof(server_address));
    
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(12345);  // Порт сервера
    
    // Преобразуем "127.0.0.1" в бинарный формат
    if (inet_pton(AF_INET, "127.0.0.1", &server_address.sin_addr) <= 0) {
        std::cerr << "ОШИБКА: Неверный адрес сервера!" << std::endl;
        close(client_socket);
        return 1;
    }
    std::cout << "✓ Адрес сервера: 127.0.0.1:12345" << std::endl;
    
    // 3. ПОДКЛЮЧЕНИЕ К СЕРВЕРУ
    std::cout << "✓ Подключение к серверу..." << std::endl;
    
    if (connect(client_socket, 
                (struct sockaddr*)&server_address, 
                sizeof(server_address)) < 0) {
        std::cerr << "ОШИБКА: Не удалось подключиться к серверу!" << std::endl;
        std::cerr << "  Убедитесь, что сервер запущен" << std::endl;
        close(client_socket);
        return 1;
    }
    std::cout << "✓ Успешное подключение к серверу!" << std::endl;
    
    // 4. ОТПРАВКА СООБЩЕНИЯ СЕРВЕРУ
    const char* message = "Привет, сервер! Это тестовое сообщение.";
    ssize_t bytes_sent = send(client_socket, message, strlen(message), 0);
    
    if (bytes_sent < 0) {
        std::cerr << "ОШИБКА: Не удалось отправить сообщение!" << std::endl;
    } else {
        std::cout << "✓ Сообщение отправлено (" << bytes_sent << " байт)" << std::endl;
        std::cout << "  Текст: " << message << std::endl;
    }
    
    // 5. ПРИЕМ ОТВЕТА ОТ СЕРВЕРА
    char buffer[1024];
    memset(buffer, 0, sizeof(buffer));
    
    std::cout << "✓ Ожидание ответа от сервера..." << std::endl;
    
    ssize_t bytes_received = recv(client_socket, buffer, sizeof(buffer) - 1, 0);
    
    if (bytes_received > 0) {
        buffer[bytes_received] = '\0';
        std::cout << "✓ Получен ответ от сервера: " << buffer << std::endl;
    } else if (bytes_received == 0) {
        std::cout << "✓ Сервер закрыл соединение" << std::endl;
    } else {
        std::cerr << "ОШИБКА при получении данных!" << std::endl;
    }
    
    // 6. ЗАКРЫТИЕ СОКЕТА
    close(client_socket);
    std::cout << "✓ Сокет закрыт" << std::endl;
    
    return 0;
}
```

## Часть 4: Работа с UDP (более простой протокол)

### UDP Сервер

```cpp
#include <iostream>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <cstring>
#include <arpa/inet.h>

int main() {
    std::cout << "=== UDP СЕРВЕР ===" << std::endl;
    
    // 1. СОЗДАНИЕ UDP-СОКЕТА
    int udp_socket = socket(AF_INET, SOCK_DGRAM, 0);
    if (udp_socket < 0) {
        std::cerr << "ОШИБКА создания сокета!" << std::endl;
        return 1;
    }
    
    // 2. ПРИВЯЗКА К АДРЕСУ
    struct sockaddr_in server_address;
    memset(&server_address, 0, sizeof(server_address));
    
    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = INADDR_ANY;
    server_address.sin_port = htons(12345);
    
    if (bind(udp_socket, (struct sockaddr*)&server_address, 
             sizeof(server_address)) < 0) {
        std::cerr << "ОШИБКА привязки!" << std::endl;
        close(udp_socket);
        return 1;
    }
    
    std::cout << "✓ UDP сервер запущен на порту 12345" << std::endl;
    
    // 3. ПРИЕМ ДАННЫХ
    char buffer[1024];
    struct sockaddr_in client_address;
    socklen_t client_len = sizeof(client_address);
    
    while (true) {
        memset(buffer, 0, sizeof(buffer));
        
        std::cout << "Ожидание данных..." << std::endl;
        
        // recvfrom для UDP (в отличие от recv для TCP)
        ssize_t bytes_received = recvfrom(udp_socket, buffer, sizeof(buffer) - 1, 0,
                                          (struct sockaddr*)&client_address, &client_len);
        
        if (bytes_received > 0) {
            buffer[bytes_received] = '\0';
            
            char client_ip[INET_ADDRSTRLEN];
            inet_ntop(AF_INET, &client_address.sin_addr, client_ip, INET_ADDRSTRLEN);
            
            std::cout << "Получено от " << client_ip << ":" 
                      << ntohs(client_address.sin_port) << ": "
                      << buffer << std::endl;
            
            // Отправка ответа
            const char* response = "UDP-ответ от сервера";
            sendto(udp_socket, response, strlen(response), 0,
                   (struct sockaddr*)&client_address, client_len);
        }
    }
    
    close(udp_socket);
    return 0;
}
```

### UDP Клиент

```cpp
#include <iostream>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <cstring>
#include <arpa/inet.h>

int main() {
    std::cout << "=== UDP КЛИЕНТ ===" << std::endl;
    
    // 1. СОЗДАНИЕ UDP-СОКЕТА
    int udp_socket = socket(AF_INET, SOCK_DGRAM, 0);
    if (udp_socket < 0) {
        std::cerr << "ОШИБКА создания сокета!" << std::endl;
        return 1;
    }
    
    // 2. НАСТРОЙКА АДРЕСА СЕРВЕРА
    struct sockaddr_in server_address;
    memset(&server_address, 0, sizeof(server_address));
    
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(12345);
    inet_pton(AF_INET, "127.0.0.1", &server_address.sin_addr);
    
    // 3. ОТПРАВКА ДАННЫХ
    const char* message = "Привет от UDP клиента!";
    
    // sendto для UDP (в отличие от send для TCP)
    ssize_t bytes_sent = sendto(udp_socket, message, strlen(message), 0,
                                (struct sockaddr*)&server_address, 
                                sizeof(server_address));
    
    if (bytes_sent > 0) {
        std::cout << "Отправлено " << bytes_sent << " байт" << std::endl;
    }
    
    // 4. ПРИЕМ ОТВЕТА
    char buffer[1024];
    socklen_t server_len = sizeof(server_address);
    
    ssize_t bytes_received = recvfrom(udp_socket, buffer, sizeof(buffer) - 1, 0,
                                      (struct sockaddr*)&server_address, &server_len);
    
    if (bytes_received > 0) {
        buffer[bytes_received] = '\0';
        std::cout << "Ответ от сервера: " << buffer << std::endl;
    }
    
    close(udp_socket);
    return 0;
}
```

## Часть 5: Важные функции для работы с сетью

### Функции преобразования данных

```cpp
#include <iostream>
#include <arpa/inet.h>
#include <netinet/in.h>

int main() {
    // 1. htons() - Host TO Network Short (16-битное число)
    uint16_t host_port = 12345;
    uint16_t network_port = htons(host_port);
    std::cout << "htons: " << host_port << " -> " << network_port << std::endl;
    
    // 2. htonl() - Host TO Network Long (32-битное число)
    uint32_t host_addr = 0x12345678;
    uint32_t network_addr = htonl(host_addr);
    std::cout << "htonl: 0x" << std::hex << host_addr 
              << " -> 0x" << network_addr << std::endl;
    
    // 3. ntohs() - Network TO Host Short (обратная htons)
    uint16_t port_back = ntohs(network_port);
    std::cout << "ntohs: " << network_port << " -> " << port_back << std::endl;
    
    // 4. Преобразование IP-адреса из строки в бинарный формат
    const char* ip_str = "192.168.1.1";
    struct in_addr bin_addr;
    
    if (inet_pton(AF_INET, ip_str, &bin_addr) == 1) {
        std::cout << "inet_pton: " << ip_str << " -> 0x" 
                  << std::hex << ntohl(bin_addr.s_addr) << std::endl;
    }
    
    // 5. Преобразование IP-адреса из бинарного в строку
    char ip_str_back[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &bin_addr, ip_str_back, INET_ADDRSTRLEN);
    std::cout << "inet_ntop: 0x" << std::hex << ntohl(bin_addr.s_addr)
              << " -> " << ip_str_back << std::endl;
    
    return 0;
}
```

## Часть 6: Обработка ошибок и лучшие практики

```cpp
#include <iostream>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <cstring>
#include <arpa/inet.h>
#include <cerrno>  // Для errno
#include <cstring> // Для strerror

void handle_error(const std::string& message) {
    std::cerr << "ОШИБКА: " << message << std::endl;
    std::cerr << "  Код ошибки: " << errno << std::endl;
    std::cerr << "  Описание: " << strerror(errno) << std::endl;
}

int main() {
    // Пример безопасного создания сокета
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        handle_error("Не удалось создать сокет");
        return 1;
    }
    
    // Установка опций сокета (опционально, но полезно)
    int opt = 1;
    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {
        handle_error("Не удалось установить SO_REUSEADDR");
        close(sock);
        return 1;
    }
    
    // Проверка доступности порта
    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    
    for (int port = 1024; port < 65535; port++) {
        addr.sin_port = htons(port);
        
        if (bind(sock, (struct sockaddr*)&addr, sizeof(addr)) == 0) {
            std::cout << "Найден свободный порт: " << port << std::endl;
            break;
        }
        
        if (errno == EADDRINUSE) {
            std::cout << "Порт " << port << " занят, пробуем следующий..." << std::endl;
            continue;
        } else {
            handle_error("Ошибка при проверке порта");
            break;
        }
    }
    
    close(sock);
    return 0;
}
```

## Часть 7: Практические советы

### 1. Компиляция программ
```bash
# Для Linux/Mac
g++ -o server server.cpp
g++ -o client client.cpp

# Для Windows (MinGW)
g++ -o server.exe server.cpp -lws2_32
g++ -o client.exe client.cpp -lws2_32
```

### 2. Проверка открытых портов
```bash
# Linux/Mac
netstat -an | grep 12345
lsof -i :12345

# Windows
netstat -an | findstr 12345
```

### 3. Тестирование с помощью telnet/netcat
```bash
# Подключение к серверу
telnet 127.0.0.1 12345
nc 127.0.0.1 12345
```

### 4. Порядок запуска
1. Сначала запустите сервер
2. Затем запустите клиент
3. Сервер должен быть запущен до подключения клиента

## Заключение

Вы изучили основы сетевого программирования на C++:

1. **Создание сокетов** - `socket()`
2. **Привязка к адресу** - `bind()`
3. **Прослушивание порта** - `listen()`
4. **Принятие соединений** - `accept()`
5. **Подключение к серверу** - `connect()`
6. **Отправка данных** - `send()` / `sendto()`
7. **Прием данных** - `recv()` / `recvfrom()`
8. **Закрытие соединений** - `close()`

**Основные отличия TCP и UDP:**
- TCP: надежный, с установкой соединения, потоковый
- UDP: быстрый, без соединения, датаграммный

**Что делать дальше:**
1. Добавьте многопоточность для обработки нескольких клиентов
2. Реализуйте протокол HTTP
3. Изучите библиотеки: Boost.Asio, POCO
4. Попробуйте IPv6 (AF_INET6)
5. Добавьте SSL/TLS шифрование

Удачи в изучении сетевого программирования!